# 认证与授权

## 认证（Authentication）方式

好的 👍
我帮你把 **.NET Core 常见认证方式**（Cookie、JWT、OAuth2.0/OpenID Connect、证书认证）分别梳理 **认证流程** 和 **实现步骤**，这样你能清晰看到它们的应用场景和代码示例。

---

### 1. Cookie 认证

#### 流程

1. 用户提交账号密码到服务端。
2. 服务端验证通过后，生成一个 **加密的认证票据（Authentication Ticket）** 并存入 Cookie。
3. 后续请求中浏览器自动带上 Cookie。
4. 服务端通过解密验证 Cookie，恢复用户身份。

#### 实现

```csharp
// Startup.cs 或 Program.cs
services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
    .AddCookie(options =>
    {
        options.LoginPath = "/Account/Login"; // 未登录时跳转
        options.AccessDeniedPath = "/Account/AccessDenied";
    });

// 登录时写入 Cookie
public async Task<IActionResult> Login(string username, string password)
{
    if (username == "admin" && password == "123456")
    {
        var claims = new List<Claim>
        {
            new Claim(ClaimTypes.Name, username),
            new Claim(ClaimTypes.Role, "Admin")
        };
        var claimsIdentity = new ClaimsIdentity(claims, CookieAuthenticationDefaults.AuthenticationScheme);
        await HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, new ClaimsPrincipal(claimsIdentity));
        return Redirect("/");
    }
    return Unauthorized();
}
```

---

### 2. JWT 认证（常用于前后端分离）

#### 流程

1. 用户提交账号密码到服务端。
2. 服务端验证成功后生成 **JWT Token**（包含用户信息和签名）。
3. 前端保存 Token（一般放 LocalStorage 或 SessionStorage）。
4. 后续请求在 `Authorization: Bearer <token>` 中传给服务端。
5. 服务端用密钥验证 Token，解析用户信息。

#### 实现

```csharp
// Startup.cs 或 Program.cs
services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = "yourIssuer",
            ValidAudience = "yourAudience",
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("SuperSecretKey12345"))
        };
    });

// 生成 Token
public string GenerateJwtToken(string username)
{
    var claims = new[]
    {
        new Claim(ClaimTypes.Name, username),
        new Claim(ClaimTypes.Role, "Admin")
    };
    var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("SuperSecretKey12345"));
    var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

    var token = new JwtSecurityToken(
        issuer: "yourIssuer",
        audience: "yourAudience",
        claims: claims,
        expires: DateTime.Now.AddHours(1),
        signingCredentials: creds);

    return new JwtSecurityTokenHandler().WriteToken(token);
}
```

---

### 3. OAuth2.0 / OpenID Connect（常用于单点登录）

#### 流程

1. 用户访问受保护资源，被重定向到 **身份提供商（IdP）**（如 Azure AD、IdentityServer、Google）。
2. 用户在 IdP 登录。
3. IdP 返回 **授权码（Authorization Code）** 给应用。
4. 应用用授权码向 IdP 请求 **Access Token / ID Token**。
5. 应用用 Token 验证用户身份，并获取用户信息。

#### 实现（以 OpenIdConnect + Azure AD 为例）

```csharp
services.AddAuthentication(options =>
{
    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = OpenIdConnectDefaults.AuthenticationScheme;
})
.AddCookie()
.AddOpenIdConnect(options =>
{
    options.Authority = "https://login.microsoftonline.com/{tenantId}/v2.0";
    options.ClientId = "your-client-id";
    options.ClientSecret = "your-client-secret";
    options.ResponseType = "code"; // 授权码模式
    options.SaveTokens = true;
    options.Scope.Add("profile");
    options.Scope.Add("email");
});
```

---

### 4. 证书认证（Client Certificate）

#### 流程

1. 客户端持有一个数字证书（.pfx）。
2. 请求时浏览器/客户端会附带证书。
3. 服务器验证证书是否可信（CA 签发、未过期、是否吊销）。
4. 验证通过后建立安全会话。

#### 实现

```csharp
services.AddAuthentication(
    CertificateAuthenticationDefaults.AuthenticationScheme)
    .AddCertificate(options =>
    {
        options.AllowedCertificateTypes = CertificateTypes.Chained; // 只允许 CA 签发的证书
        options.Events = new CertificateAuthenticationEvents
        {
            OnCertificateValidated = context =>
            {
                var claims = new[]
                {
                    new Claim(ClaimTypes.NameIdentifier, context.ClientCertificate.Subject, ClaimValueTypes.String, context.Options.ClaimsIssuer),
                    new Claim(ClaimTypes.Name, context.ClientCertificate.Subject, ClaimValueTypes.String, context.Options.ClaimsIssuer)
                };
                context.Principal = new ClaimsPrincipal(new ClaimsIdentity(claims, context.Scheme.Name));
                context.Success();
                return Task.CompletedTask;
            }
        };
    });
```
---

## ASP.NET Core 授权机制对比

在 ASP.NET Core 中，授权主要分为三类：

### **基于角色的授权（Role-based Authorization）**

- 核心思想：

* 用户被分配一个或多个 **角色（Role）**，访问时根据角色判断权限。

🔹 用法示例：

```csharp
[Authorize(Roles = "Admin")]
public IActionResult AdminOnly()
{
    return View();
}
```

🔹 特点：

* 简单、直观。
* 适合 **角色固定** 的系统（比如：管理员 / 普通用户 / 访客）。
* 缺点：扩展性差，如果权限需求越来越复杂，角色数量会爆炸（角色膨胀问题）。

---

### **基于声明的授权（Claims-based Authorization）**

👉 核心思想：

* 用户身份包含一组 **声明（Claims）**，声明是“键值对”，比如：

  * `Department = Sales`
  * `Permission = ReadOrders`

🔹 用法示例：

```csharp
[Authorize(Policy = "SalesOnly")]
public IActionResult SalesAction()
{
    return View();
}

// Startup / Program.cs 中定义策略
services.AddAuthorization(options =>
{
    options.AddPolicy("SalesOnly",
        policy => policy.RequireClaim("Department", "Sales"));
});
```

🔹 特点：

* 比角色更灵活，权限可以基于任意属性判断。
* 常用于 **多租户系统**、**需要细粒度控制的业务**。
* 缺点：策略写多了，管理可能比较复杂。

---

### **基于策略的授权（Policy-based Authorization）**

👉 核心思想：

* 将授权逻辑抽象为 **策略（Policy）**，策略里可以包含角色、声明，甚至自定义逻辑。

🔹 用法示例：

```csharp
[Authorize(Policy = "Over18Only")]
public IActionResult AdultContent()
{
    return View();
}

// Startup / Program.cs
services.AddAuthorization(options =>
{
    options.AddPolicy("Over18Only", policy =>
        policy.Requirements.Add(new MinimumAgeRequirement(18)));
});

// 自定义 Handler
public class MinimumAgeRequirement : IAuthorizationRequirement
{
    public int Age { get; }
    public MinimumAgeRequirement(int age) => Age = age;
}

public class MinimumAgeHandler : AuthorizationHandler<MinimumAgeRequirement>
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        MinimumAgeRequirement requirement)
    {
        var birthdate = context.User.FindFirst(c => c.Type == ClaimTypes.DateOfBirth);
        if (birthdate != null)
        {
            var age = DateTime.Today.Year - DateTime.Parse(birthdate.Value).Year;
            if (age >= requirement.Age)
                context.Succeed(requirement);
        }
        return Task.CompletedTask;
    }
}
```

🔹 特点：

* 最灵活，可封装复杂的业务逻辑。
* 适合需要 **复杂规则、组合条件** 的企业系统。
* 缺点：开发成本稍高，需要写 `Handler`。

---

### 对比

| 特性     | 基于角色       | 基于声明                 | 基于策略               |
| -------- | -------------- | ------------------------ | ---------------------- |
| 简单性   | ⭐⭐⭐⭐           | ⭐⭐⭐                      | ⭐                      |
| 灵活性   | ⭐              | ⭐⭐⭐                      | ⭐⭐⭐⭐                   |
| 适用场景 | 角色分明的系统 | 多租户、按属性区分权限   | 复杂规则、多条件判断   |
| 扩展性   | 差（角色膨胀） | 中等（依赖 Claims 管理） | 高（可自定义 Handler） |

---
