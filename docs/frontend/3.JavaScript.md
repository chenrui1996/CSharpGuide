# JavaScript

## 介绍

**`JavaScript`（通常缩写为JS）是一门基于 `原型` 和 `头等函数` 的 `多范式` `高级` `解释型` 编程语言，它支持  `面向对象`  程序设计、 `指令式编程`  和  `函数式编程` 。**

**它提供方法来操控文本、数组、日期以及正则表达式等。**

**不支持I/O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。**

**它由`Ecma`通过`ECMAScript`实现语言的标准化。**

目前，它被世界上的绝大多数网站所使用，也被世界主流浏览器（Chrome、Firefox、Safari和Opera）所支持。

JavaScript与Java在名字和语法上都很相似，但这两门编程语言从设计之初就有很大不同。
JavaScript在语言设计上主要受到了`Self`（一种基于原型的编程语言）和`Scheme`（一门函数式编程语言）的影响，
在语法结构上它和C语言很相似（如`if`条件语句、`switch`语句、`while`循环和`do-while`循环等）。

::: tip ECMAScript 
`JavaScript` 是语言，`ECMAScript` 是规范。

`JavaScript` 是 `ECMAScript` 的实现之一（还有如 `JScript`、`ActionScript`）

---

**几个重要的`ECMAScript` 版本:**
1. **ES3（1999）**
- 第一个广泛支持的版本
- 引入：正则表达式、异常处理（try-catch）、switch、do...while

2. **ES5（2009）**
- 大规模应用前的标准，兼容性强
- 特性：
  - "use strict" 严格模式
  - Array.prototype.forEach/map/filter
  - Object.defineProperty
  - JSON.parse / JSON.stringify

3. **ES6 / ECMAScript 2015**
- JavaScript 的一次重大变革
- 引入现代开发核心语法：
  - let / const
  - 箭头函数 ()=>{}
  - 类（class）、模块（import/export）
  - 解构赋值、模板字符串、默认参数
  - Promise
  - Map / Set

4. **ES8 / ECMAScript 2017**
- 引入了 异步编程革命
- 特性：
  - async/await（写异步代码像同步代码）
  - Object.entries / Object.values

5. **ES11 / ECMAScript 2020**
- 现代语法糖丰富
- 特性：
  - 可选链操作符 ?.
  - 空值合并操作符 ??
  - Promise.allSettled
  - 动态 import()
:::

## 基本用法

### 插入方式

- **内联方式**

``` html
<button onclick="alert('点击了按钮')">点我</button>
```

- **内部脚本**

``` html
<script>
  console.log('页面加载完成');
</script>
```

- **外部引入（推荐做法）**

``` html
<script src="main.js"></script>
```

::: warning 推荐引入方式
**推荐 `HTML` 末尾引入外部 `JS`**
``` html
<body>
  <!-- 页面内容 -->

  <script src="main.js"></script> <!-- 放在 body 末尾 -->
</body>
```

**优点：**
- 提升页面加载速度
浏览器解析 `HTML` 是自上而下的，如果 `JS` 写在前面，会阻塞 `DOM` 构建。而写在后面可以先加载内容，提升用户体验。

- 确保 `DOM` 元素已加载
当 JS 执行时，页面中的元素已经加载完成，避免出现 `document.getElementById(...) is null` 这类错误。

- 无需等待或写 `DOMContentLoaded`
不用额外包装代码在：
``` js
document.addEventListener("DOMContentLoaded", () => {
  // code here
});
```

**若放在 `<head>` 中，使用 `defer`延迟执行，等 DOM 完成后才运行。**

``` html
<script src="main.js" defer></script>
```
:::

### 执行过程

1. `HTML` 解析 → 浏览器解析 `HTML`，从上到下构建 `DOM` 树；
2. 遇到 `<script>` 标签 → 浏览器暂停 `HTML` 解析，执行 `JS` 脚本；
3. 同步执行代码 → `JavaScript` 是**单线程**的，按顺序同步执行；
4. 操作 `DOM` 或**响应事件** → 可以通过 `JS` 修改页面内容、响应用户操作；
5. 异步任务（如 `setTimeout`、`fetch`） → 放入**任务队列**，等待主线程空闲时执行。

## 变量

在 JavaScript 中，**变量是用于存储数据值的容器**。理解变量是 JS 编程的基础之一。

---

### JS 中声明变量的三种方式

| 关键字     | 作用域   | 是否可重复声明 | 是否可修改值    | 是否提升 | 说明            |
| ------- | ----- | ------- | --------- | ---- | ------------- |
| `var`   | 函数作用域 | ✅ 是     | ✅ 是       | ✅ 是  | 早期使用方式，灵活但易出错 |
| `let`(ES6)   | 块级作用域 | ❌ 否     | ✅ 是       | ❌ 否  | 推荐用于可变变量      |
| `const`(ES6) | 块级作用域 | ❌ 否     | ❌ 否（值不能变） | ❌ 否  | 推荐用于常量或不可变引用  |

---

### 变量的使用示例

```js
// var 示例（不推荐）
var x = 5;
var x = 10; //  允许重复声明

// let 示例（推荐）
let a = 3;
// let a = 4; //  报错：不能重复声明
a = 4;       //  可修改

// const 示例（推荐用于常量）
const PI = 3.14;
// PI = 3.1415; //  报错：不可修改
```

---

### 作用域

#### 函数作用域（`var`）

```js
function test() {
  var message = "hello";
}
console.log(message); // 报错，message 在函数外不可访问
```

#### 块级作用域（`let` 和 `const`）

```js
{
  let score = 100;
}
// console.log(score); // 报错，score 在块外不可访问
```

---

#### 变量提升（仅 `var`）

`var` 声明的变量会被提升（Hoisting）到当前作用域的顶部，这个“作用域”可以是：

- 当前的 函数作用域（如果 `var` 在函数内声明）
- 当前的 全局作用域（如果 `var` 在函数外声明）

```js
console.log(a); // undefined （已声明但未赋值）
var a = 5;
```

等价于：

```js
var a;
console.log(a);
a = 5;
```

> `let` 和 `const` **也会提升，但它们的初始化不会被提升。在声明之前访问这些变量会导致ReferenceError。，访问会直接报错（称为“暂时性死区”）**。

参考：[深究一下let、const到底有没有提升？](https://juejin.cn/post/6993676334635417614)

---

::: warning 推荐用法
- **推荐使用 `let` 代替 `var`**
  - `var` 会“泄露”出当前代码块，导致变量被意外访问或污染。
  - `let` 不允许重复声明同名变量（更安全）
  - `var` 会被提升到作用域顶部，容易造成未定义变量被错误使用。
  - `let` 为每次循环创建了新的作用域，`var` 只创建一次作用域。

  比如：使用 `var` 时 `for` 循环中的异步操作出错

  ``` js
  for (var i = 0; i < 3; i++) {
    setTimeout(function () {
      console.log("var i:", i);
    }, 100);
  }

  //输出
  //1. var i: 3
  //2. var i: 3
  //3. var i: 3

  // 原因：  1. 循环 0, i = 0; => 2. 把 setTimeout(() => console.log(i)) 放入宏任务队列 
  //        => 3. 循环 1, i = 1; => 4. 把 setTimeout(() => console.log(i)) 放入宏任务队列
  //        => 5. 循环 2, i = 2; => 6. 把 setTimeout(() => console.log(i)) 放入宏任务队列
  //        => 7. i++，变为 3，不再满足循环条件，循环结束 
  //        => 8. 主线程空闲，宏任务队列执行， 输出 var i: 3; var i: 3; var i: 3;
  ```

  应该使用：
  
  ``` js
  for (let i = 0; i < 3; i++) {
    setTimeout(function () {
      console.log("let i:", i);
    }, 100);
  }

  //输出
  //1. let i: 0
  //2. let i: 1
  //3. let i: 2

  // 原因：  1. 循环 0, 创建新的块作用域, 创建 let i = 0; => 2. 把 setTimeout(() => console.log(i)) (捕获 i=0) 放入宏任务队列 
  //        => 3. 循环 1, 创建新的块作用域, 创建 let i = 1; => 4. 把 setTimeout(() => console.log(i)) (捕获 i=1) 放入宏任务队列
  //        => 5. 循环 2, 创建新的块作用域, 创建 let i = 2; => 6. 把 setTimeout(() => console.log(i)) (捕获 i=2) 放入宏任务队列
  //        => 7. i++，变为 3，不再满足循环条件，循环结束 
  //        => 8. 主线程空闲，宏任务队列执行， 输出 let i: 0; let i: 1; let i: 2;

  ```

  也可以使用 使用 var + IIFE（立即执行函数表达式）：
  ``` js
  for (var i = 0; i < 3; i++) {
    (function (j) {
      setTimeout(() => {
        console.log("var+j i:", j);
      }, 0);
    })(i);
  }

  //输出
  //1. var+j i: 0
  //2. var+j i: 1
  //3. var+j i: 2

  // 原因
  // 每次循环时，调用一个立即执行函数，将 i 的值传进去
  // 这个 j 是参数，属于 IIFE 的局部变量
  // 回调闭包捕获的是 j，不会被后续循环影响
  ```

- **用 `const` 声明不会改变的值（如配置信息、常量）**
- **避免重复声明变量**
- **避免不使用 `var`、`let` 或 `const` 来声明变量而直接赋值，会被自动变成window全局变量（在非严格模式下）**

:::

---

## 数据类型
JavaScript 的数据类型分为 **基本类型（primitive types）** 和 **引用类型（reference types）**。

---

### 基本类型（Primitive Types）

基本类型是不可变、按值传递的。

| 类型          | 示例                              | 说明                               |
| ----------- | ------------------------------- | -------------------------------- |
| `number`    | `42`, `3.14`, `NaN`, `Infinity` | 所有数字，包含整数和浮点数                    |
| `string`    | `'hello'`, `"world"`            | 字符串                              |
| `boolean`   | `true`, `false`                 | 布尔值                              |
| `undefined` | `let x;` → `x === undefined`    | 未赋值时的默认值                         |
| `null`      | `null`                          | 表示“空值”或“无对象”                     |
| `bigint`    | `1234567890123456789012345n`    | 超过 `Number.MAX_SAFE_INTEGER` 的整数 |
| `symbol`    | `Symbol('id')`                  | 创建独一无二的值（常用于对象属性）                |

>  基本类型是**不可变的值类型**：`x = y` 赋值后两者互不影响。


::: warning 四舍五入

| 场景         | 用法                              |
| ---------- | ------------------------------- |
| 四舍五入整数     | `Math.round(num)`               |
| 保留 `n` 位小数 | `Math.round(num * 10^n) / 10^n` |
| 转字符串保留小数   | `num.toFixed(n)`                |
| 精确金融运算(精度丢失)     | `decimal.js` 等库                 |
| 银行家舍入      | 自定义函数                           |

:::


::: warning toString
在 JavaScript 中，`toString()` 方法可以将**对象、数组、数值、函数等**转为字符串，但不同类型的 `toString()` 行为和格式是不同的，下面是详细的分类讲解与格式说明：

---

1. 基本数据类型的 `toString()` 格式

- **数字类型**

```js
let num = 255;
console.log(num.toString());     // "255"
console.log(num.toString(2));    // "11111111"（二进制）
console.log(num.toString(16));   // "ff"（十六进制）
```

* `Number.prototype.toString([radix])`
* `radix` 是进制（2–36），默认为 10

---

- **布尔类型**

```js
true.toString();   // "true"
false.toString();  // "false"
```

---

- **字符串类型**

字符串调用 `toString()` 不变：

```js
"hello".toString();  // "hello"
```

---

2. **引用类型的 `toString()` 格式**

- **数组**

```js
[1, 2, 3].toString();     // "1,2,3"
[null, undefined].toString();  // ","
[].toString();            // ""
```

* 等价于 `Array.prototype.join(',')`

---

- **对象**

```js
({ a: 1 }).toString();    // "[object Object]"
```

默认行为是：

```js
Object.prototype.toString.call(value); // 标准类型标签
```

例如：

```js
Object.prototype.toString.call([]);           // "[object Array]"
Object.prototype.toString.call(null);         // "[object Null]"
Object.prototype.toString.call(new Date());   // "[object Date]"
```

---

- **函数**

```js
function greet() { return "hi"; }
console.log(greet.toString());
```

输出函数的源码字符串：

```js
"function greet() { return \"hi\"; }"
```

---

- **Date 对象**

```js
new Date().toString(); // e.g. "Tue May 13 2025 17:40:00 GMT+0800 (China Standard Time)"
```

| 方法名                | 返回值示例                                       | 描述               |
| ------------------ | ------------------------------------------- | ---------------- |
| `toString()`       | `"Tue May 13 2025 20:30:00 GMT+0800 (CST)"` | 本地时间字符串（默认）      |
| `toDateString()`   | `"Tue May 13 2025"`                         | 本地日期（无时间）        |
| `toTimeString()`   | `"20:30:00 GMT+0800 (CST)"`                 | 本地时间（无日期）        |
| `toUTCString()`    | `"Tue, 13 May 2025 12:30:00 GMT"`           | UTC 格式字符串        |
| `toISOString()`    | `"2025-05-13T12:30:00.000Z"`                | ISO 8601 格式（UTC） |
| `toLocaleString()` | `"2025/5/13 20:30:00"`（取决于地区）               | 本地化日期+时间         |
|                    |                                             |                  |


---

- **自定义对象的 `toString()` 方法**

你可以自定义对象的 `toString()` 方法：

```js
const person = {
  name: "Alice",
  toString() {
    return `Person: ${this.name}`;
  }
};

console.log(person + "");  // "Person: Alice"
```

---

- **原型链上的 `toString()` 差异**

所有对象继承自 `Object.prototype`，如果你没有覆写 `toString()`，就会默认返回 `"[object Object]"`。你可以使用：

```js
Object.prototype.toString.call(value);
```

来获取**准确的类型标签**：

| 值           | 返回                     |
| ----------- | ---------------------- |
| `[]`        | `"[object Array]"`     |
| `{}`        | `"[object Object]"`    |
| `null`      | `"[object Null]"`      |
| `undefined` | `"[object Undefined]"` |
| `1`         | `"[object Number]"`    |
| `/regex/`   | `"[object RegExp]"`    |

:::

::: tip symbol
| 特点        | 说明                                            |
| --------- | --------------------------------------------- |
| 唯一性       | 每次调用 `Symbol()` 都会生成一个独一无二的值                  |
| 不可隐式转换字符串 | 与字符串拼接时会报错，只能显式转成字符串                          |
| 可作为对象键    | 可用作对象属性的唯一键，不会与其他键冲突                          |
| 不可枚举      | 用 `for...in`、`Object.keys()` 等方法无法获取 Symbol 键 |
| 支持全局注册表   | 通过 `Symbol.for()` 实现跨文件共享同一个 Symbol 值         |

---

**示例：**

``` js
// 创建 symbol
const id1 = Symbol('id');
const id2 = Symbol('id');
console.log(id1 === id2); // false（唯一性）

// 用作对象键
const user = {
  [id1]: 123
};
console.log(user[id1]);   // 123

// Symbol 不能和字符串自动拼接
// console.log("User ID is: " + id1); // ❌ TypeError
console.log("User ID is: " + id1.toString()); // ✅

```

---

**Symbol.for() vs Symbol()**

``` js
const a = Symbol.for('key');
const b = Symbol.for('key');
console.log(a === b); // true（从全局注册表获取）

const x = Symbol('key');
const y = Symbol('key');
console.log(x === y); // false（每次唯一）

```

---

**内置symbol（Well-known Symbols）**

内置 `Symbol` 是 `JavaScript` 提供的一组预定义 `Symbol` 值，它们挂在全局 `Symbol` 对象上，用于改变对象的默认行为或与语言底层机制交互。

| 内置 Symbol                   | 类型/接口            | 用途简述                                          |
| --------------------------- | ---------------- | --------------------------------------------- |
| `Symbol.iterator`           | 可迭代协议            | 对象支持 `for...of`、展开运算符                         |
| `Symbol.asyncIterator`      | 异步可迭代协议          | 支持 `for await...of` 的异步迭代器                    |
| `Symbol.toPrimitive`        | 类型转换             | 控制对象转换为原始值时的行为                                |
| `Symbol.toStringTag`        | 类型标签             | 控制 `Object.prototype.toString.call(obj)` 的返回值 |
| `Symbol.hasInstance`        | `instanceof` 运算符 | 控制某个对象被 `instanceof` 判断时的结果                   |
| `Symbol.isConcatSpreadable` | 数组操作             | 控制 `concat()` 时是否将对象“展开”                      |
| `Symbol.species`            | 构造函数派生           | 控制像 `.map()` 这样的方法返回什么构造函数创建的对象               |
| `Symbol.match`              | 字符串匹配            | 自定义 `str.match(obj)` 行为                       |
| `Symbol.replace`            | 字符串替换            | 自定义 `str.replace(obj)` 行为                     |
| `Symbol.search`             | 字符串搜索            | 自定义 `str.search(obj)` 行为                      |
| `Symbol.split`              | 字符串拆分            | 自定义 `str.split(obj)` 行为                       |
| `Symbol.unscopables`        | `with` 语句        | 指定对象属性在 `with` 环境中是否可用（一般不推荐使用）               |

示例：

- **`Symbol.iterator`**

定义对象的默认迭代器，让对象可用于 `for...of`、展开语法等。

```js
const myIterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  }
};
console.log([...myIterable]); // [1, 2, 3]
```

---

- **`Symbol.toPrimitive`**

控制对象到原始类型（如数字或字符串）的转换行为。

```js
const obj = {
  [Symbol.toPrimitive](hint) {
    return hint === "number" ? 42 : "custom";
  }
};
console.log(+obj);     // 42
console.log(`${obj}`); // "custom"
```

---

- **`Symbol.toStringTag`**

定义对象的类型标签，影响 `Object.prototype.toString.call()` 的输出。

```js
const obj = {
  [Symbol.toStringTag]: "MyTag"
};
console.log(Object.prototype.toString.call(obj)); // "[object MyTag]"
```

---

- **`Symbol.hasInstance`**

控制对象是否为某个构造函数的“实例”。

```js
class MyClass {
  static [Symbol.hasInstance](instance) {
    return instance.name === "special";
  }
}
console.log({ name: "special" } instanceof MyClass); // true
```

---

- **`Symbol.isConcatSpreadable`**

决定对象在 `concat()` 中是否被“打平”。

```js
const arrLike = {
  0: "a",
  1: "b",
  length: 2,
  [Symbol.isConcatSpreadable]: true
};
console.log(["x"].concat(arrLike)); // ["x", "a", "b"]
```

---

- **`Symbol.species`**

控制子类方法如 `map()`、`filter()` 等返回的构造函数。

```js
class MyArray extends Array {
  static get [Symbol.species]() {
    return Array;
  }
}
const a = new MyArray(1, 2, 3);
const b = a.map(x => x * 2);
console.log(b instanceof MyArray); // false
console.log(b instanceof Array);   // true
```

---

- **`Symbol.match` / `replace` / `search` / `split`**

自定义字符串方法行为。

```js
const matcher = {
  [Symbol.match](str) {
    return str.includes("test");
  }
};
console.log("This is a test".match(matcher)); // true
```

---

- **`Symbol.unscopables`**

定义 `with` 环境中哪些属性应被忽略（不推荐使用 `with`）。

```js
const obj = {
  foo: 1,
  [Symbol.unscopables]: { foo: true }
};
```

:::

---

### 引用类型（Reference Types）

引用类型是可变的，存的是对象的**地址引用**。

| 类型         | 示例                | 说明            |
| ---------- | ----------------- | ------------- |
| `Object`   | `{name: 'Alice'}` | 所有对象的基类       |
| `Array`    | `[1, 2, 3]`       | 数组            |
| `Function` | `function() {}`   | 函数本质上是对象      |
| `Date`     | `new Date()`      | 日期对象          |
| `RegExp`   | `/\d+/`           | 正则表达式         |
| `Map`      | `new Map()`       | 键值对集合（键可为任意值） |
| `Set`      | `new Set()`       | 不重复值集合        |

> 引用类型是**按引用传递**，多个变量可以指向同一对象。

---

### 类型判断方法

JavaScript 是**动态类型语言**，变量类型在运行时决定，因此：

- 类型判断在调试、数据验证、类型保护、函数参数处理等场景非常关键。
- 不同类型的判断方式适用场景不同，选择错误可能会导致 bug。

---


#### `typeof` — 判断基础类型

```js
typeof 123        // "number"
typeof 'abc'      // "string"
typeof true       // "boolean"
typeof undefined  // "undefined"
typeof Symbol()   // "symbol"
typeof BigInt(1)  // "bigint"
typeof function(){} // "function"
```

❗ **陷阱：**

```js
typeof null     // "object" ❌ 历史 bug
typeof []       // "object" ❌
```

---

#### `instanceof` — 判断引用类型是否由某构造函数创建

```js
[] instanceof Array              // true
{} instanceof Object             // true
new Date() instanceof Date       // true
(() => {}) instanceof Function   // true
```

❗ **限制：**

* 无法判断基础类型（例如 `123 instanceof Number` 为 false）
* 不适合跨 iframe、window 判断（构造函数不同）

---

#### `Object.prototype.toString.call(val)` — 万能判断法

这是最准确的方式。

```js
Object.prototype.toString.call(123);       // [object Number]
Object.prototype.toString.call('abc');     // [object String]
Object.prototype.toString.call(null);      // [object Null]
Object.prototype.toString.call(undefined); // [object Undefined]
Object.prototype.toString.call([]);        // [object Array]
Object.prototype.toString.call({});        // [object Object]
Object.prototype.toString.call(() => {});  // [object Function]
```

✅ **优势：**

* 可判断任意数据类型
* 最精确，不受构造函数影响

---

#### `Array.isArray()` — 判断数组的推荐方式

```js
Array.isArray([]);        // true
Array.isArray({});        // false
Array.isArray('abc');     // false
```

比 `instanceof Array` 更稳健（能跨 iframe 判断）。

---

#### `.constructor` — 查看构造函数

```js
(123).constructor === Number         // true
'abc'.constructor === String         // true
[].constructor === Array             // true
({}).constructor === Object          // true
```

❗ **风险：** 可被人为更改：

```js
const arr = [];
arr.constructor = Object;
arr.constructor === Array;  // false ❌
```

---

#### 推荐组合方案

| 目标         | 推荐方式                                  |
| ---------- | ------------------------------------- |
| 判断基础类型     | `typeof`                              |
| 判断是否为数组    | `Array.isArray()`                     |
| 判断 null    | `val === null`                        |
| 判断引用类型准确类型 | `Object.prototype.toString.call(val)` |
| 判断某类实例     | `val instanceof Constructor`          |

---

#### 函数封装

```js
function getType(val) {
  return Object.prototype.toString.call(val).slice(8, -1);
}

// 示例：
getType(null);        // "Null"
getType([]);          // "Array"
getType({});          // "Object"
getType(() => {});    // "Function"
getType(new Date());  // "Date"
```

---

#### 跨 iframe/window 类型

每个 `iframe` 或 `window` 中都有自己的 `JavaScript` 全局环境（也就是自己的 `globalThis`、`window`、`Object`、`Array` 等构造函数）。

所以：`iframe1.Array !== iframe2.Array`, 虽然你在两个窗口中都写了 new Array()，**它们是不同的构造函数实例。**

``` html
<!-- 假设在主页面中引用了一个 iframe -->
<iframe id="myFrame" src="iframe.html"></iframe>

<script>
  const iframeWin = document.getElementById('myFrame').contentWindow;
  const arr = new iframeWin.Array();
  arr instanceof Array; // false （与当前的window是不同的构造函数）
</script>
```

由于 `instanceof` 比较的是 构造函数的引用地址，会在跨 `window` 场景失败，因此应该使用：`Object.prototype.toString.call(arr);` 
这个方法只看内部 [[Class]] 标签，不受构造函数影响，因此跨上下文判断是安全的


### 类型转换

JavaScript 的类型转换是一个核心概念，因为它是一门**动态类型语言**，变量的数据类型可以自动转换。类型转换可以分为两大类：

---

- **显式类型转换（Explicit Conversion）**

开发者通过代码**手动**进行类型转换。

例如：

```js
Number("123")   // 123
String(123)     // "123"
Boolean(0)      // false
```

---

- **隐式类型转换（Implicit Conversion）**

JavaScript 引擎在运行时自动进行的转换，也叫**类型强制转换**（Type Coercion）。

例如：

```js
"5" + 1        // "51"（1 被转成字符串）
"5" - 1        // 4   （"5" 被转成数字）
true + 1       // 2   （true 转为 1）
```

---

#### 转换规则

1. **转为字符串（String）**

- 显式：

```js
String(123)         // "123"
String(true)        // "true"
String(null)        // "null"
String(undefined)   // "undefined"
String({})          // "[object Object]"
```

- 隐式：

```js
123 + "abc"         // "123abc"
true + "test"       // "truetest"
```

> 加号 `+` 运算符涉及字符串时，会触发转字符串。

---

2. **转为数字（Number）**

- 显式：

```js
Number("123")       // 123
Number("abc")       // NaN
Number(true)        // 1
Number(false)       // 0
Number(null)        // 0
Number(undefined)   // NaN
```

- 隐式：

```js
"6" * 2             // 12
"6" - 1             // 5
true + 1            // 2
null + 1            // 1
```

> 除了加号 `+`，其他数学运算符都会触发数字转换。

---

3. **转为布尔值（Boolean）**

- 显式：

```js
Boolean(0)          // false
Boolean("")         // false
Boolean(null)       // false
Boolean(undefined)  // false
Boolean(NaN)        // false
Boolean([])         // true
Boolean({})         // true
```

- 隐式：

在以下场景中，会触发布尔转换：

* `if (value)`
* `while (value)`
* 三元运算符：`value ? a : b`
* 逻辑运算符：`&&`、`||`、`!`

示例：

```js
if ("hello") { console.log("yes"); } // 输出 "yes"
```

---

5. **对象到原始值的转换（ToPrimitive）**

当对象参与运算（比如加法或比较），会尝试转为原始值。

转换顺序：

1. `Symbol.toPrimitive`
2. 先调用 `obj.valueOf()`，如果是原始值就返回；
3. 否则再调用 `obj.toString()`；
4. 如果仍不是原始值，就报错。

示例：

```js
let obj = {
  valueOf() { return 42; },
  toString() { return "hello"; }
};

obj + 1    // 43
```

::: warning 空对象 `{}` 的默认行为
``` js
console.log([]);  // ""

const obj = {};
console.log(obj.valueOf());   // 返回自身对象：{}
console.log(obj.toString());  // "[object Object]"

{} + 1  // → "[object Object]" + 1 → "[object Object]1"

//注意，下面情况 JS 解释器把 {} 解析为代码块，这时它就被忽略了
{} + []  // → [] → ""

//想明确表示它是对象，必须加括号
({} + [])  // → "[object Object]"

```
:::

---

6. **特殊值转换行为**

| 值           | 转为 Boolean | 转为 Number | 转为 String          |
| ----------- | ---------- | --------- | ------------------ |
| `undefined` | false      | NaN       | "undefined"        |
| `null`      | false      | 0         | "null"             |
| `true`      | true       | 1         | "true"             |
| `false`     | false      | 0         | "false"            |
| `""`        | false      | 0         | ""                 |
| `"123"`     | true       | 123       | "123"              |
| `"abc"`     | true       | NaN       | "abc"              |
| `[]`        | true       | 0         | ""                 |
| `[1,2]`     | true       | NaN       | "1,2"              |
| `{}`        | true       | NaN       | "\[object Object]" |

---

#### ==（宽松等于）和 ===（严格等于）的区别

- **`==` 会进行类型转换：**

```js
0 == false       // true
"" == false      // true
null == undefined // true
```

- **`===` 不进行类型转换：**

```js
0 === false      // false
"" === false     // false
null === undefined // false
```

::: warning 常见面试题

**尽量使用 `===` ！！！**

``` js
[] == false   // true
// [] == false
// → [] 转成原始值 '' → '' == false
// → '' 转成数字 0，false 也转成 0 → 0 == 0

[] == ![]     // true
// [] == ![]
// → ![] 是 false，所以变成 [] == false（同上）

null == undefined // true

// 对象与对象比较的是引用，不是值。
{} == {}; // false
[] == []; // false

// NaN 不等于自身，是 JS 中少数需要特判的值
NaN === NaN        // false
isNaN(NaN)         // true
Number.isNaN(NaN)  // true（更严格）
```

::: 

---


## 运算符

JavaScript 的运算符（operators）是构建表达式和控制程序逻辑的核心工具。它们可以操作数值、字符串、对象等不同类型的数据。下面是 JS 中常见运算符的分类和用法讲解。

---

### 算术运算符（Arithmetic Operators）

用于执行数学计算：

| 运算符  | 含义     | 示例       | 结果         |
| ---- | ------ | -------- | ---------- |
| `+`  | 加法     | `3 + 2`  | `5`        |
| `-`  | 减法     | `3 - 2`  | `1`        |
| `*`  | 乘法     | `3 * 2`  | `6`        |
| `/`  | 除法     | `3 / 2`  | `1.5`      |
| `%`  | 取模（余数） | `5 % 2`  | `1`        |
| `**` | 幂运算    | `2 ** 3` | `8`        |
| `++` | 自增     | `a++`    | 先返回 a，再加 1 |
| `--` | 自减     | `--a`    | 先减 1，再返回 a |

---

### 赋值运算符（Assignment Operators）

用于给变量赋值或更新变量值：

| 运算符   | 含义    | 示例        | 等同于          |
| ----- | ----- | --------- | ------------ |
| `=`   | 赋值    | `x = 5`   |              |
| `+=`  | 加并赋值  | `x += 2`  | `x = x + 2`  |
| `-=`  | 减并赋值  | `x -= 3`  | `x = x - 3`  |
| `*=`  | 乘并赋值  | `x *= 4`  | `x = x * 4`  |
| `/=`  | 除并赋值  | `x /= 2`  | `x = x / 2`  |
| `%=`  | 取模并赋值 | `x %= 2`  | `x = x % 2`  |
| `**=` | 幂并赋值  | `x **= 3` | `x = x ** 3` |

---

### 比较运算符（Comparison Operators）

用于判断两个值之间的关系，结果为布尔值（true 或 false）：

| 运算符   | 含义       | 示例          | 结果      |
| ----- | -------- | ----------- | ------- |
| `==`  | 相等（类型转换） | `'5' == 5`  | `true`  |
| `!=`  | 不相等      | `'5' != 5`  | `false` |
| `===` | 全等（值和类型） | `'5' === 5` | `false` |
| `!==` | 不全等      | `'5' !== 5` | `true`  |
| `>`   | 大于       | `5 > 3`     | `true`  |
| `<`   | 小于       | `5 < 3`     | `false` |
| `>=`  | 大于等于     | `5 >= 5`    | `true`  |
| `<=`  | 小于等于     | `5 <= 3`    | `false` |

---

### 逻辑运算符（Logical Operators）

用于多条件判断或控制表达式执行：

| 运算符  | 含义     | 示例       | 说明               | 
| ---- | ---------| -------- | ------------------------- |
| `&&` | 与（and） | `a && b` | a 为真则返回 b，否则返回 a |
| `\|\|` |  或（or） | `a \|\| b` | a 为真则返回 a，否则返回 b | 
| `!`  | 非（not） | `!true`  | 取反：false               |

::: warning 逻辑运算符的短路行为
`&&` 和 `||` 不一定返回布尔值，而是返回最后计算的操作数。

``` js
console.log(0 || "default");   // "default"
console.log("hello" && 123);   // 123
console.log(false && "fail");  // false

```

:::

---

### 位运算符（Bitwise Operators）

用于对二进制位进行操作（一般用于底层优化或特殊逻辑）：

| 运算符   | 含义    | 示例         | 说明                         |     |        |               |
| ----- | ----- | ---------- | -------------------------- | --- | ------ | ------------- |
| `&`   | 按位与   | `5 & 3`    | `0101 & 0011 = 0001`       |     |        |               |
| \`    | \`    | 按位或        | \`5                        | 3\` | \`0101 | 0011 = 0111\` |
| `^`   | 按位异或  | `5 ^ 3`    | `0101 ^ 0011 = 0110`       |     |        |               |
| `~`   | 按位取反  | `~5`       | `~00000101 = 11111010`（负数） |     |        |               |
| `<<`  | 左移    | `5 << 1`   | `1010`（乘以 2）               |     |        |               |
| `>>`  | 右移    | `5 >> 1`   | `2`（除以 2）                  |     |        |               |
| `>>>` | 无符号右移 | `-5 >>> 1` | 得到正整数                      |     |        |               |

---

### 三元运算符（三目运算符）

```js
const result = condition ? value1 : value2;
```

示例：

```js
let age = 18;
let type = age >= 18 ? "adult" : "child"; // "adult"
```

---

### typeof 和 instanceof 运算符

| 运算符          | 含义        | 示例                              |
| ------------ | --------- | ------------------------------- |
| `typeof`     | 返回数据类型字符串 | `typeof "abc"` → `"string"`     |
| `instanceof` | 判断对象类型    | `arr instanceof Array` → `true` |

---

### 解构与展开（ES6+）

虽然不属于传统运算符，但也像运算符使用：

- **解构赋值**：

```js
//数组解构
const [a, b] = [1, 2];
const [x, , y] = [10, 20, 30];  // x=10, y=30

//对象结构
const { x, y } = { x: 1, y: 2 };
//使用别名
const { name: userName } = person;
//使用默认值
const { gender = "unknown" } = person;
//undefined会被默认值覆盖但null不会
const [a = 1] = [undefined];  // a = 1
const [b = 2] = [null];       // b = null（不是默认值）

```

- **展开运算符**：

```js
//数组展开
const arr = [1, 2, 3];
const newArr = [...arr, 4, 5];  // [1, 2, 3, 4, 5]

//克隆数组
const copy = [...arr];

//组合多个数组
const all = [...arr1, ...arr2];

//对象展开
const obj = { a: 1, b: 2 };
const copy = { ...obj };           // 克隆
const merged = { ...obj, c: 3 };   // 合并新字段

//冲突覆盖
const o1 = { a: 1 };
const o2 = { a: 2, b: 3 };
const merged = { ...o1, ...o2 }; // { a: 2, b: 3 }

//对象展开拷贝只有一层
const o1 = { a: { b: 1 } };
const o2 = { ...o1 };
o2.a.b = 2;
console.log(o1.a.b);  // 2

```

---

## 表达式

在 JavaScript 中，\*\*表达式（Expression）**是任何能产生**值（value）\*\*的代码。它与“语句”不同 —— 语句是“做某事”，而表达式是“返回某个值”。

---

### 什么是表达式

一个表达式是可以被计算（evaluated）并且返回一个值的代码单位，例如：

```js
3 + 4              // 表达式，结果是 7
"hello"            // 表达式，结果是 "hello"
x = 5              // 表达式，结果是 5（赋值表达式）
myFunction()       // 表达式，返回函数执行结果
```

---

### 表达式的类型

#### **原始值表达式**

直接使用字面量：

```js
42         // 数字
"JS"       // 字符串
true       // 布尔
null       // null
undefined  // undefined
```

::: tip 字面量
**字面量（Literal）**是指在代码中直接写出的、表示固定值的写法。

简单来说，字面量就是你写在代码里的**值本身**，不需要计算或函数调用。
:::

---

#### **变量表达式**

访问变量名就是表达式：

```js
let x = 10;
x; // 表达式，结果是 10
```

---

#### **算术表达式**

返回数学运算结果：

```js
3 + 5 * 2     // 13
(10 - 2) / 4  // 2
```

---

#### **赋值表达式**

赋值操作本身是表达式，会返回被赋的值：

```js
let y;
y = 7         // 表达式，值是 7
let z = (y = 3); // z = 3
```

---

#### **逻辑表达式**

`&&`、`||`、`!` 是逻辑运算符：

```js
true && false  // false
"hello" || "world"  // "hello"
```

> 常用于默认值判断：

```js
let name = inputName || "Guest";
```

---

#### **比较表达式**

返回布尔值的表达式：

```js
5 > 3         // true
"a" === "a"   // true
```

---

#### **函数表达式**

- **匿名函数表达式：**

```js
const greet = function(name) {
  return "Hi, " + name;
};
```

- **箭头函数表达式：**

```js
const add = (a, b) => a + b;
```

:::

---

#### **调用表达式**

调用函数并返回值：

```js
sayHello()       // 返回函数结果
Math.max(3, 7)   // 返回 7
```

---

#### **数组/对象表达式**

```js
[1, 2, 3]           // 数组表达式
{ name: "JS" }      // 对象表达式
```

---

### 表达式 vs 语句的区别

| 项目  | 表达式     | 语句               |
| --- | ------- | ---------------- |
| 定义  | 产生值的代码  | 执行动作的代码          |
| 示例  | `3 + 4` | `let x = 3 + 4;` |
| 返回值 | 有返回值    | 无返回值             |
| 用法  | 可嵌套在语句中 | 不可嵌套在表达式中        |

---

### 特殊表达式：条件（三元）表达式

```js
let result = (score >= 60) ? "Pass" : "Fail";
```

这是一种表达式，不是语句，返回一个值。

---


## 语句

在 JavaScript 中，**语句（statement）**是用来执行特定操作的代码单位。每一条语句告诉浏览器执行一件事，比如声明变量、判断条件、循环、调用函数等。

---

### **声明语句**

用于创建变量、常量或函数。

* `var`、`let`、`const`：声明变量或常量

```js
let name = "Alice";
const PI = 3.14;
var age = 30;
```

* `function`：声明函数

```js
function greet() {
  console.log("Hello!");
}
```

---

### **表达式语句**

表达式可以被当作语句使用（即表达式后加分号）。

```js
x = 5 + 3;
console.log(x);
```

---

### **条件语句**

根据条件执行不同的代码块。

* `if` / `else if` / `else`

```js
if (score > 90) {
  console.log("Excellent!");
} else if (score > 60) {
  console.log("Passed.");
} else {
  console.log("Failed.");
}
```

* `switch`

```js
switch (day) {
  case 1: console.log("Monday"); break;
  case 2: console.log("Tuesday"); break;
  default: console.log("Unknown");
}
```

---

### **循环语句**

反复执行代码块。

* `for`

```js
for (let i = 0; i < 5; i++) {
  console.log(i);
}
```

* `while`

```js
let i = 0;
while (i < 5) {
  console.log(i);
  i++;
}
```

* `do...while`

```js
let i = 0;
do {
  console.log(i);
  i++;
} while (i < 5);
```

* `for...in` / `for...of`

```js
for (let key in obj) { ... }
for (let item of array) { ... }
```

---

### **跳转语句**

控制流程转向。

* `break`：跳出循环或 `switch`
* `continue`：跳过本次循环
* `return`：从函数返回
* `throw`：抛出异常

---

### **异常处理语句**

处理程序运行时的错误。

```js
try {
  riskyFunction();
} catch (error) {
  console.error("Error occurred:", error);
} finally {
  console.log("Cleanup code.");
}
```

---

### **空语句**

只有一个分号，什么都不做，偶尔用于占位。

```js
;
```

::: tip

**语句通常以分号（`;`）结尾**，虽然 JavaScript 有自动分号插入机制，但最好显式写出分号以避免意外错误。

:::

---



## 函数

在 JavaScript 中，**函数（Function）**是核心概念之一，是用来封装可重用代码块的机制。它是 JavaScript 的**一等公民**，可以像变量一样传递、赋值、嵌套。

---

### 函数的定义方式

#### 1. **函数声明（Function Declaration）**

```js
function greet(name) {
  return "Hello, " + name;
}
```

::: danger 函数提升

`JavaScript` 引擎在代码执行前，会先**预处理** **变量** 和 **函数** 的 **声明**，把它们提升到**作用域**的顶部。

``` js
foo(); // "hello"
function foo() {
  console.log("hello");
}

```

:::


---

#### 2. **函数表达式（Function Expression）**

```js
const greet = function(name) {
  return "Hello, " + name;
};
```

::: danger 函数表达式不会提升

``` js
bar(); // TypeError: bar is not a function
var bar = function () {
  console.log("hi");
};

//var bar 被提升（值为 undefined）但函数赋值在运行阶段才赋上去

```

:::

---

#### 3. **箭头函数（Arrow Function）**

```js
const greet = name => "Hello, " + name;
```

- **箭头函数的`this`指向**

普通函数的 `this` 是调用时绑定，动态决定；

而箭头函数不会创建自己的 `this`，而是继承外层作用域的 `this`。

**不建议用箭头函数作为对象方法，因为 this 不是指向对象，而是定义时的外层上下文。**

``` js
function Timer() {
  this.seconds = 0;
  setInterval(() => {
    this.seconds++;
    console.log(this.seconds); // 正常访问 Timer 实例的 this
  }, 1000);
}
new Timer();


const obj = {
  count: 10,
  doSomethingLater: function () {
    setTimeout(() => {
      console.log(this.count);
    }, 1000);
  }
};

obj.doSomethingLater(); //输出 10，因为箭头函数继承了 doSomethingLater 的 this，即 obj。

const obj1 = {
  count: 10,
  doSomethingLater: function () {
    setTimeout(function () {
      console.log(this.count);
    }, 1000);
  }
};

obj1.doSomethingLater(); //输出 function，因为普通函数继动态绑定this，可以使用.bind(this)或者使用 self 或 that 保存 this 实现类似功能。

```

- **箭头函数不能作为构造函数（不能用 new）**

箭头函数没有 `[[Construct]]` 内部方法，没有 prototype 属性。

``` js
const Person = (name) => {
  this.name = name;
};
const p = new Person('Tom'); // ❌ TypeError: Person is not a constructor

```

- **箭头函数没有 arguments 对象**

箭头函数中访问不到 arguments，可以用 rest 参数代替。

``` js
const logArgs = (...args) => {
  console.log(args);
};

```

- **箭头函数不能使用 yield，因此不能定义为 generator 函数**

``` js
const gen = *() => { 
  yield 1;
  yield 2;
  yield 3; 
} // ❌ SyntaxError
```

- **箭头函数的返回值**

``` js
const add = (a, b) => { a + b };
console.log(add(2, 3)); //输出 undefined。箭头函数使用大括号时必须写 return，否则默认不返回值。

```
---

#### 4. **匿名函数（Anonymous Function）**

**没有名字的函数，多用于回调。**

```js
setTimeout(function() {
  console.log("Hello");
}, 1000);
```

---

#### 5. **立即执行函数（IIFE）**

**立即执行函数（Immediately Invoked Function Expression,）是一个被立即调用的函数表达式（不是函数声明），一般用来创建作用域。** 

```js
(function() { ... })();   // 常见写法
(function() { ... }());   // 也可以
!function() { ... }();     // 也可以（少见写法）
+function() { ... }();     // 有效（但不推荐）

```

**应用：**

- 封装变量，避免污染全局

``` js
var x = 100;

(function () {
  var x = 10;
  console.log("内部x:", x); // 10
})();

console.log("全局x:", x); // 100

```

- 初始化代码执行一次

``` js
const config = (function () {
  const apiKey = "abc123";
  const env = "production";
  return { apiKey, env };
})();

```

-  在循环中“锁定”变量值（使用 var）

``` js
for (var i = 0; i < 3; i++) {
  (function (j) {
    setTimeout(() => {
      console.log(j); // 0, 1, 2
    }, j * 1000);
  })(i);
}

```

---

### 函数的参数

#### 1. 默认参数

```js
function greet(name = "Guest") {
  return `Hello, ${name}`;
}
```

#### 2. 剩余参数（Rest Parameters）

```js
function sum(...numbers) {
  return numbers.reduce((a, b) => a + b);
}
```

#### 3. arguments 对象（仅普通函数）

```js
function showArgs() {
  console.log(arguments);
}
```

---

### 函数特点

- 函数可以作为值赋给变量：

  ```js
  const sayHi = function() {};
  ```
- 函数可以作为参数传递：

  ```js
  function callLater(callback) {
    callback();
  }
  ```
- 函数可以作为返回值返回：

  ```js
  function multiplier(x) {
    return function(y) {
      return x * y;
    };
  }
  ```

---

### 作用域链与闭包

- **什么是作用域**

**作用域（Scope）**是变量的可访问范围。`JavaScript` 有以下几种作用域：

  - **全局作用域**：在所有函数外定义的变量（包括未声明直接赋值的变量）；
  - **函数作用域**：函数内部定义的变量只能在函数内访问；
  - **块级作用域（ES6）**：使用 let / const 在 {} 中定义的变量仅在块内有效。

- **什么是作用域链？**

当访问变量时，`JavaScript` 会从当前**作用域**开始查找，若找不到，就沿着**父作用域**一层层向上查找，直到**全局作用域**为止。这个查找路径形成了**作用域链**。

**作用域链是词法静态的，取决于函数定义位置，而非调用位置。**

示例：

``` js
var a = 10;

function outer() {
  var b = 20;

  function inner() {
    var c = 30;
    console.log(a, b, c);
  }

  inner();
}

outer(); // 输出：10 20 30

//查找变量 a：在 inner 中找不到，去 outer，再去全局。[inner → outer → global]
```

### 闭包

**闭包是指一个函数能够访问其词法作用域中定义的变量，即使这个函数是在其作用域外被调用的。**

换句话说：

**函数 + 它所捕获的作用域变量 = 闭包**

```js
function outer() {
  let x = 10;
  return function inner() {
    console.log(x); // 闭包访问外层作用域
  };
}
```

**创建闭包的常见方式**

- **返回函数**

``` js
function outer() {
  var count = 0;
  return function () {
    count++;
    console.log(count);
  };
}

const counter = outer();
counter(); // 1
counter(); // 2

```

- **在异步中使用**

``` js
function greet(name) {
  setTimeout(function () {
    console.log("Hello, " + name);
  }, 1000);
}

greet("Alice");

```

- **使用闭包实现私有变量**

**js中没有访问修饰符。**

``` js
function createCounter() {
  let count = 0; // 私有变量

  return {
    increment() {
      count++;
      console.log(count);
    },
    decrement() {
      count--;
      console.log(count);
    }
  };
}

const counter = createCounter();
counter.increment(); // 输出：1
counter.increment(); // 输出：2
counter.decrement(); // 输出：1

```

::: danger 注意

- 闭包会导致变量不会被释放，可能导致内存泄露，慎重使用
- 每个闭包都会创建新的作用域链 ，大量使用会带来性能问题
- 闭包和 `this` 无直接关系， `this` 是运行时绑定，与闭包无关

:::

---

## 对象

在 JavaScript 中，\*\*对象（Object）**是最核心的数据类型之一，用于存储**键值对（key-value）\*\*的数据结构。

---

### 什么是对象？

对象是一个由**属性和方法**组成的无序集合。

```js
const person = {
  name: "Alice",
  age: 30,
  greet: function () {
    console.log("Hello, I'm " + this.name);
  }
};
```

* `name` 和 `age` 是 **属性（property）**
* `greet()` 是 **方法（method）**
* `this` 指向当前对象

---

### 对象的创建方式

#### 1. 对象字面量（最常用）

```js
const obj = { a: 1, b: 2 };
```

#### 2. 使用 `new Object()`

```js
const obj = new Object();
obj.a = 1;
```

#### 3. 使用构造函数

```js
function Person(name) {
  this.name = name;
}
const p = new Person("Tom");
```

#### 4. 使用 `Object.create(proto)`

```js
const parent = { greet() { console.log("Hi"); } };
const child = Object.create(parent);
child.name = "Child";
```

#### 5. 使用类（ES6）

```js
class Animal {
  constructor(type) {
    this.type = type;
  }
}
const dog = new Animal("dog");
```

---

### 属性访问与操作

```js
const obj = { name: "Bob", age: 25 };

// 点语法
console.log(obj.name); // "Bob"

// 中括号语法（适合变量动态访问）
console.log(obj["age"]); // 25

// 添加属性
obj.gender = "male";

// 删除属性
delete obj.age;
```

---

### 遍历对象属性

#### 1. `for...in`（可枚举自身+继承属性）

```js
for (let key in obj) {
  console.log(key, obj[key]);
}
```

#### 2. `Object.keys()` / `Object.values()` / `Object.entries()`

```js
Object.keys(obj);    // ['name', 'gender']
Object.values(obj);  // ['Bob', 'male']
Object.entries(obj); // [['name', 'Bob'], ['gender', 'male']]
```

---

### 对象的引用特性

```js
const a = { value: 10 };
const b = a;
b.value = 20;
console.log(a.value); // 20（引用指向同一个对象）
```

---

### 对象的常用方法

| 方法                 | 说明                 |
| ------------------ | ------------------ |
| `Object.assign()`  | 合并对象，浅拷贝           |
| `Object.create()`  | 创建新对象并指定原型         |
| `Object.keys()`    | 获取属性名数组            |
| `Object.values()`  | 获取属性值数组            |
| `Object.entries()` | 获取键值对数组            |
| `Object.freeze()`  | 冻结对象，不可变           |
| `Object.seal()`    | 封闭对象：可修改，不能添加/删除属性 |

---

### 原型与原型链

对象都有一个隐藏属性 `[[Prototype]]`（可通过 `__proto__` 或 `Object.getPrototypeOf()` 访问），用于继承属性。

```js
const parent = { a: 1 };
const child = Object.create(parent);
console.log(child.a); // 1（继承而来）
```

### 原型模式

### 工厂函数

---

### this

```js
const obj = {
  name: "Tom",
  say() {
    console.log(this.name);
  }
};
obj.say(); // Tom

const fn = obj.say;
fn(); // undefined（this 不再指向 obj）
```

---

### 对象比较

```js
const obj1 = { a: 1 };
const obj2 = { a: 1 };
console.log(obj1 === obj2); // false（不同引用）
```

---

### 结构赋值与扩展运算符

```js
const person = { name: "Alice", age: 25 };
const { name } = person; // 解构
const copy = { ...person }; // 浅拷贝
```

---


## 提升

## 数组与集合

## 事件

## 异步编程

## DOM

## BOM

## Http请求

## 模块化

