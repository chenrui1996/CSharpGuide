# Vue

## 介绍

`Vue` 是一款用于构建用户界面的 ***渐进式*** `JavaScript` 框架。它基于标准 `HTML` `CSS` 和 `JavaScript` 构建，并提供了一套 ***声明式*** 的、***组件化*** 的编程模型，帮助你高效地开发用户界面。

::: tip 声明

`Vue` 有极其完备的文档：https://cn.vuejs.org/

根据文档可以快速上手，解决问题，集成生态。

本文档仅从个人角度介绍 `Vue` 的常见应用与问题, 文档demo仓库：https://github.com/chenrui1996/vue-demo。

，详细文档请参考官网。

:::

::: warning 渐进式框架
`Vue` 是一个框架，也是一个生态。其功能覆盖了大部分前端开发常见的需求。

但 Web 世界是十分多样化的，不同的开发者在 Web 上构建的东西可能在形式和规模上会有很大的不同。

考虑到这一点，Vue 的设计非常注重灵活性和“可以被逐步集成”这个特点。

根据你的需求场景，你可以用不同的方式使用 `Vue`：

- 无需构建步骤，渐进式增强**静态**的 `HTML`.
- 在任何页面中作为 `Web Components` 嵌入
- **单页应用 (SPA)**
- **全栈 / 服务端渲染 (SSR)**
- **Jamstack / 静态站点生成 (SSG)**
- **开发桌面端、移动端、WebGL，甚至是命令行终端中的界面**
:::

::: warning 常见前端渲染方式
| 渲染方式            | 简介                                                           | 应用场景示例                                                             |
| ------------------- | -------------------------------------------------------------- | ------------------------------------------------------------------------ |
| SSR（服务端渲染）   | 页面 HTML 在服务器生成，浏览器接收到完整 HTML 再显示           | Razor Pages、Blazor Server                                               |
| CSR（客户端渲染）   | 后端仅返回数据，页面结构和渲染逻辑在浏览器中由 JavaScript 执行 | Vue/React SPA                                                            |
| SSG（静态站点生成） | 编译时生成静态 HTML，部署时直接提供                            | [Nuxt 静态模式](https://nuxt.com/)、[Jekyll](https://www.jekyll.com.cn/) |
| ISR（增量静态生成） | 静态页面支持按需重新生成，结合 SSG 与 SSR 的优点               | [Next.js](https://nextjs.org/) ISR 模式                                  |
| 混合渲染（Hybrid）  | 某些页面 SSR，某些页面 CSR，结合使用                           | [Nuxt](https://nuxt.com/)、[Next.js](https://nextjs.org/) 支持按路由配置 |
| Prerender（预渲染） | 构建阶段预先执行 JS，生成 HTML 快照                            | Vue Prerender 插件                                                       |

:::

::: danger vue2 与 vue3
1. Vue 2 已在 2023 年 12 月 31 日到达它的截止维护日期。在此之后，Vue 2 在已有的分发渠道 (各类 CDN 和包管理器) 中仍然可用，**但不再进行更新，包括对安全问题和浏览器兼容性问题的修复等。**
2. 大部分 Vue 3 重要的特性移植回了 Vue 2.7，包括组合式 API 和 `<script setup>`。如果打算留在 Vue 2，应该至少升级至 2.7。
3. Vue 2 升级到vue3参考 [vue3迁移指南](https://v3-migration.vuejs.org/zh/breaking-changes/key-attribute.html)
4. Vue 3 提供了更小的包体积、更好的性能、更好的可扩展性和更好的 TypeScript/IDE 支持。但Vue 3 用到了一些 IE11 不支持的现代 JavaScript 特性。
5. vue 3 相对vue 2的优化
   1. Vue 3 重写了虚拟 DOM，使其更快、更轻量，内存占用更低。Patch 过程更高效，diff 算法更智能。
   2. Vue 3 使用模块化架构，支持 `Tree-shaking`，打包时可以剔除未使用的功能，减小体积。
   3. 核心库比 Vue 2 更轻量（压缩后约 10KB 左右，比 Vue 2 小约 50%）。
   4. 编译器能更好地标记静态节点，减少运行时开销。
   5. Vue 3 使用 `Proxy` 代替 vue 2中的 `Object.defineProperty`（无法监听数组索引、新增属性等） 实现响应式，能监听几乎所有操作，包括新增、删除、嵌套属性变更等。
   6. `Composition API` 替代 `Options API` 的局限性。
   7. Vue 3 重写代码为 TypeScript，原生支持，开发体验更好。
   8. ref, `reactive`, `computed`, `watch`, `watchEffect` 等新的响应式工具函数。`provide` / `inject` 更适合逻辑复用。
:::

## 创建应用

### 准备工作

::: warning node.js
[Node.js](https://nodejs.org/zh-cn) 是一个免费、开源、跨平台的 `JavaScript` 运行时环境, 

它允许开发者在**服务器端**使用 `JavaScript` 编写应用程序，从而实现前后端统一的开发语言。

---

- **核心特点**
  - 事件驱动与非阻塞 I/O：Node.js 采用单线程架构，结合事件循环机制和异步 I/O 操作，能够高效地处理大量并发连接，适用于 I/O 密集型应用，如 Web 服务器和实时通信工具。 
  - 高性能：得益于 V8 引擎的优化，Node.js 在执行 JavaScript 代码时表现出色，适合构建高性能的网络应用。
  - 丰富的生态系统：通过内置的 npm（Node Package Manager），开发者可以方便地安装和管理第三方模块，加速开发流程。 
  - 跨平台支持：Node.js 可在 Windows、Linux 和 macOS 等多个操作系统上运行，适应多样化的部署需求。

---

- **`Vue` 中为什么要使用 `node.js`**

  **1. 开发工具链依赖 Node.js**
    - Vue CLI / Vite：官方脚手架工具（如 Vue CLI 或 Vite）需要 Node.js 环境来初始化项目、管理依赖和运行开发服务器。
    - 热重载（HMR）：开发时的模块热更新依赖 Node.js 提供的本地服务器能力。
    - 构建工具：webpack、Rollup 或 Vite 等工具需要 Node.js 执行代码打包、压缩、转译等操作

  **2. npm/yarn/pnpm 包管理**
     - Vue 生态系统的大量第三方库（如 vue-router、pinia、axios）通过 npm/yarn 安装，这些工具基于 Node.js。

  **3. 前端工程化需求**
     - 模块化开发：Node.js 支持 ES Modules/CommonJS，方便组织现代前端代码。
     - 编译转换：Vue 单文件组件（.vue）需要 vue-loader 或 @vitejs/plugin-vue 转译为浏览器可执行的 JS，这需要 Node.js 环境。
     - 预处理语言：Sass/Less/TypeScript 等需通过 Node.js 工具链编译。

  **4. 服务端渲染（SSR）**
     - 使用 Nuxt.js 或直接配置 Vue SSR 时，需要 Node.js 作为服务器渲染 Vue 组件并返回 HTML，提升首屏性能和 SEO。

  **5. API 代理与 Mock 数据**
     - 开发时可通过 Node.js 服务器代理 API 请求，解决跨域问题（如 vite.config.js 中的 proxy 配置）。
     - 使用 Mock.js 等工具模拟后端接口。

  **6. 自动化与脚本**
     - 通过 Node.js 编写脚本处理重复任务（如批量生成组件、部署前优化等）。
---

- **可不可以不用 Node.js**
  - 直接引入：直接下载最新版本，通过 `<script>` 标签引入 `Vue`，或直接引入 `CDN`， 适合简单页面或学习，但无法享受工程化优势。
  - 静态生成：使用 Vue 构建纯静态站点（如通过 vitepress）后，生产环境只需静态服务器（如 Nginx）。

---


:::

::: tip webpack
[Webpack](https://webpack.js.org/) 是一个功能强大的前端构建工具和模块打包器，广泛应用于现代 JavaScript 应用程序的开发中。

它能够将项目中的各种资源（如 JavaScript、CSS、图片等）视为模块，构建出清晰的依赖关系图，并将这些模块打包成可供浏览器使用的静态文件。

---

- 核心概念

  1. 入口（Entry）

  入口指示 Webpack 应该从哪个模块开始构建依赖图。默认情况下，Webpack 会从 `./src/index.js` 作为入口。

  ```javascript
  module.exports = {
    entry: './src/index.js',
  };
  ```

  对于多页面应用，可以指定多个入口点。

  2. 输出（Output）

  输出配置告诉 Webpack 如何命名和存储打包后的文件。

  ```javascript
  module.exports = {
    output: {
      filename: 'bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
  };
  ```

  `filename` 指定输出文件的名称，`path` 指定输出目录的绝对路径。

  3. 加载器（Loaders）

  加载器使 Webpack 能够处理非 JavaScript 文件，如 CSS、图片等。它们在模块加载时进行转换，使这些资源能够被添加到依赖图中。

  ```javascript
  module.exports = {
    module: {
      rules: [
        {
          test: /\.css$/,
          use: ['style-loader', 'css-loader'],
        },
      ],
    },
  };
  ```

  上述配置允许 Webpack 处理 `.css` 文件，并将其注入到 JavaScript 中。

  4. 插件（Plugins）

  插件用于执行范围更广的任务，如打包优化、资源管理、环境变量注入等。

  ```javascript
  const HtmlWebpackPlugin = require('html-webpack-plugin');

  module.exports = {
    plugins: [
      new HtmlWebpackPlugin({ template: './src/index.html' }),
    ],
  };
  ```
  `HtmlWebpackPlugin` 插件会根据提供的模板生成一个 HTML 文件，并自动引入打包后的资源。

  5. 模式（Mode）

  Webpack 提供了三种模式：`development`、`production` 和 `none`。设置不同的模式会启用相应的优化。

  ```javascript
  module.exports = {
    mode: 'development', // 或 'production'、'none'
  };
  ```

  * `development`：启用有利于开发的设置，如未压缩的输出和详细的错误信息。
  * `production`：启用优化设置，如代码压缩和性能提升。

---
:::

::: tip Vue CLI（基于 Webpack）
Vue CLI（Command Line Interface）是 Vue.js 官方提供的脚手架工具，旨在帮助开发者快速搭建和管理 Vue 项目。

> Vue CLI 现已处于维护模式!
> 现在官方推荐使用 create-vue 来创建基于 Vite 的新项目。 另外请参考 Vue 3 工具链指南 以了解最新的工具推荐。

[官网](https://cli.vuejs.org/zh/)

:::

::: warning Vite
Vite 是一个现代化的前端构建工具，于 2020 年发布，旨在通过利用现代浏览器的原生 ES 模块支持，提供快速的开发体验。

[官网](https://cn.vite.dev/), [为什么选 Vite](https://cn.vite.dev/guide/why.html)

:::

### 创建一个 Vue 应用

[官网文档](https://cn.vuejs.org/guide/quick-start)

- **需要安装 Node.js**

> **若本地需要多个版本的Node.js，可以使用 [NVM](https://github.com/coreybutler/nvm-windows) 管理**

**Vue 和 Node.js 版本**

| Vue 版本 | 推荐 Node.js 版本 | 构建工具建议        | 生命周期状态 |
| -------- | ----------------- | ------------------- | ------------ |
| Vue 2.x  | 10 – 16           | Vue CLI 4.x         | 已停止维护   |
| Vue 3.x  | 18.3 及以上       | Vite / Vue CLI 4.5+ | 活跃维护中   |

- **需要安装 `create-vue`(默认集成了 `Vite` 作为构建工具的 `Vue` 官方提供的脚手架工具)**
 
> **如未安装建议全局安装`npm install -g  create-vue@latest`**

---

#### 创建步骤

1. **运行以下命令**
``` sh
npm create vue@latest
```

  **可选功能提示：**

``` sh
◇  请输入项目名称：
│  vue-demo
│
◆  请选择要包含的功能： (↑/↓ 切换，空格选择，a 全选，回车确认)
│  ◻ TypeScript
│  ◻ JSX 支持
│  ◻ Router（单页面应用开发）
│  ◻ Pinia（状态管理）
│  ◻ Vitest（单元测试）
│  ◻ 端到端测试
│  ◻ ESLint（错误预防）
│  ◻ Prettier（代码格式化）
```

2. **安装依赖**
``` sh
cd <your-project-name>
npm install
```

3. **启动开发服务器**
``` sh
cd <your-project-name>
npm run dev
```

4. **发布到生产环境**

``` sh
npm run build
```

---

#### 目录结构分析

```bash
my-vue-app/
├── node_modules/
├── public/
│   ├── favicon.ico
│   └── index.html
├── src/
│   ├── assets/
│   ├── components/
│   ├── App.vue
│   └── main.js
├── .gitignore
├── babel.config.js
├── package.json
├── README.md
└── vue.config.js (可选)
```

1. **`node_modules/`**

* 自动生成的依赖文件夹，存放项目用到的所有 npm 包。
* **不需要手动更改内容，通常不提交到 Git 仓库。**

2. **`public/`**

* 存放静态资源，打包时内容**原样拷贝**到最终的构建目录 (`dist`)。

| 文件/目录     | 说明                                                                                     |
| ------------- | ---------------------------------------------------------------------------------------- |
| `index.html`  | 入口 HTML 模板，Vue 应用会挂载在这里的 `<div id="app"></div>` 中。你可以自定义头部内容。 |
| `favicon.ico` | 网站图标，可替换。                                                                       |

3. **`src/`**

* 项目源码目录，是开发的主要区域。

| 文件/目录     | 说明                                                                       |
| ------------- | -------------------------------------------------------------------------- |
| `main.js`     | 应用入口文件，创建 Vue 实例并挂载到 `#app`。通常在此注册全局组件、插件等。 |
| `App.vue`     | 根组件，通常作为整个应用的框架壳，里面包含 `<router-view>` 或页面结构。    |
| `components/` | 存放 Vue 单文件组件（`.vue`），如按钮、表单、模块等 UI 单元组件。          |
| `assets/`     | 存放静态资源，如图片、字体等，会被 Webpack 处理（例如 hash 命名）。        |

* 若启用 Vue Router / Vuex，CLI 可能还会添加这些目录：

| 目录      | 用途                                                 |
| --------- | ---------------------------------------------------- |
| `views/`  | 路由页面组件（每个页面一个 `.vue` 文件）             |
| `router/` | Vue Router 配置文件，通常是 `index.js`，包含路由表。 |
| `store/`  | Vuex 状态管理目录。                                  |

4. **配置文件**

| 文件名            | 作用                                                     |
| ----------------- | -------------------------------------------------------- |
| `.gitignore`      | 配置 Git 忽略哪些文件（如 `node_modules/`）              |
| `package.json`    | 描述项目及依赖、脚本等信息。最核心的项目配置文件。       |
| `babel.config.js` | Babel 配置，用于转译 JavaScript 新语法。                 |
| `vue.config.js`   | Vue CLI 配置文件，可配置打包路径、代理、Webpack 设置等。 |
| `README.md`       | 项目说明文档，可填写使用方法、目录说明、运行步骤等。     |

---

#### 运行过程

> 在 Web 服务器中（如 Apache、Nginx、Vite 的 dev server），访问目录时会默认查找 index.html 作为入口文件。

``` mermaid
graph TD
    A[运行 npm run dev] --> B[Vite 启动开发服务器]
    B --> C[读取 index.html]
    C --> D[查找并执行 main.js]
    D --> E[main.js 创建 Vue 实例]
    E --> F[加载 App.vue]
    F --> G[App.vue 渲染并挂载到 #app]
    G --> H[Vue 应用开始运行]

```

---

#### 构建过程

``` mermaid
graph TD
    A[运行 npm run build] --> B[Vite 读取 vite.config.js]
    B --> C[解析 public/index.html]
    C --> D[找到入口文件 main.js]
    D --> E[Rollup 递归分析依赖]
    E --> F[代码分割 & Tree shaking]
    F --> G[应用插件 压缩、转换 ]
    G --> H[生成构建输出文件  dist/ ]
    H --> I[构建完成，可部署]

```

## 基础

### 模板语法

`Vue` 使用一种基于 `HTML` 的模板语法，使我们能够**声明式**地将其组件**实例的数据** **绑定**到呈现的 `DOM` 上。
> 所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。

在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。

结合**响应式系统**，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。

| 功能         | 语法                            |
| ------------ | ------------------------------- |
| 插值         | `{ { message } }`               |
| 属性绑定     | `:href="url"`                   |
| 事件绑定     | `@click="handleClick"`          |
| 双向数据绑定 | `v-model="message"`             |
| 动态 class   | `:class="{ active: isActive }"` |
| 动态 style   | `:style="{ color: textColor }"` |

- **应用示例：**

``` vue
<script setup>
import { ref } from 'vue'

const message = ref('Hello Vue!')
const url = ref('https://vuejs.org')
const isVisible = ref(true)
const items = ref(['苹果', '香蕉', '橘子'])
const isActive = ref(true)
const textColor = ref('blue')

function handleClick() {
  alert('按钮被点击了！')
}
</script>

<template>
  <!-- 插值语法 -->
  <h1>{{ message }}</h1>

  <!-- 双向绑定 -->
  <input v-model="message" placeholder="修改 message" />

  <hr/>

  <!-- 属性绑定 -->
  <a :href="url" target="_blank">访问链接</a>

  <hr/>
  <!-- 条件渲染 -->
  <input v-model="isVisible" type="checkbox" />

  <p v-if="isVisible" style="display: inline-block;">这个段落是可见的。</p>
  <p v-else style="display: inline-block;">这个段落是不可见的。</p>

  <hr/>

  <!-- 列表渲染 -->
  <ul>
    <li v-for="(item, index) in items" :key="index">
      {{ index + 1 }} - {{ item }}
    </li>
  </ul>

  <hr/>

  <!-- 事件处理 -->
  <button v-on:click="handleClick">点击我</button>
  <button @click="handleClick">点击我</button>

  <hr/>

  <!-- 绑定 class 和 style -->
  <!-- 插值语法不起作用，插值语法不会被当作属性解析 -->
  <p :class="{ active: isActive }" :style="{ color: textColor }">
    动态 class 和 style 示例
  </p>
</template>

<style lang="sass" scoped>

</style>
```

---

- **渲染流程**

``` mermaid
graph TD
  A[模板 template] --> B[编译器 compiler]
  B --> C[渲染函数 render function]
  C --> D[虚拟 DOM VNode]
  D --> E[真实 DOM 初次渲染]

  subgraph 响应式更新流程
    F[响应式数据改变] --> G[依赖追踪触发更新]
    G --> C
    C --> D2[新的 VNode]
    D2 --> H[Diff 对比新旧 VNode]
    H --> I[Patch 更新 DOM]
  end

  E --> F

```

---

1. **模板编译**

在开发时，你写的：

```html
<h1>{{ message }}</h1>
```

Vue 编译器会将其转换为类似这样的 JavaScript 渲染函数（伪代码）：

```js
function render(ctx) {
  return h('h1', null, ctx.message)
}
```

* `h()` 是 Vue 创建虚拟 DOM 的函数（Hyperscript）
* `ctx` 是组件实例的上下文，里面包含了 `message`

> ⚠️ 注意：Vue 3 的模板在构建阶段由 `@vue/compiler-dom` 预编译成 `render` 函数，这样运行时就更高效。

---

2. **响应式绑定（Reactivity）**

Vue 使用响应式系统（基于 `Proxy`）追踪依赖：

```js
const message = ref('Hello')
```

当组件第一次渲染时，Vue 会把 `message` 读取过程记录为依赖。

当你修改它：

```js
message.value = 'Hi'
```

Vue 会触发对应的渲染函数再次执行，生成新的 **VNode 树（虚拟 DOM）**。

---

3. **虚拟 DOM 比较（Diff）和 Patch**

每次响应式数据变动时，Vue 会：

1. 使用新的数据生成新的虚拟 DOM（VNode）
2. 与旧的虚拟 DOM 进行 diff 比较
3. 通过最小化更新操作，**打补丁**到真实 DOM 上（patch）

> 优点：性能高，不需要完全重新渲染 DOM，只更新变动的部分。

---

- **注意事项**

1. **插值语法不能用于 HTML 属性**

```html
<!-- 错误 -->
<a href="{{ url }}">点击</a> <!-- 不会解析 -->

<!-- 正确 -->
<a :href="url">点击</a>
```

插值 `{{ }}` 只能用于元素内容，不能用于属性。

---

2.  **`v-bind` 简写为 `:`，`v-on` 简写为 `@`**

```html
<!-- 完整写法 -->
<img v-bind:src="imageUrl">
<button v-on:click="submit">提交</button>

<!-- 推荐写法 -->
<img :src="imageUrl">
<button @click="submit">提交</button>
```

---

3.  **模板中不能使用 JavaScript 语句**

```html
<!-- 错误 -->
<p>{{ if (ok) { return 'yes' } }}</p>

<!-- 正确（表达式可以） -->
<p>{{ ok ? 'yes' : 'no' }}</p>
```

> 只能写**表达式**，不能写完整语句（如 if、for、while、return 等）。

---

4. **双向绑定 (`v-model`) 只能用于表单元素**

```html
<!-- 正确 -->
<input v-model="username" />

<!-- 错误 -->
<!-- v-model 不能用在 <div>、<p> 等非表单元素上 -->
<div v-model="username"></div>
```

---

5. **绑定 class/style 推荐使用对象或数组语法**

```html
<!-- 推荐 -->
<p :class="{ active: isActive }"></p>
<p :style="{ color: textColor }"></p>

<!-- 不推荐 -->
<p class="{{ isActive ? 'active' : '' }}"></p> <!-- 无效 -->
```

---

6. **根节点只能有一个（在 Vue 2）**

* Vue 2：模板只能有一个根元素（如 `<div>`）
* Vue 3：允许多个根节点

---

7. **HTML 会被自动转义，除非使用 `v-html`**

```html
<!-- 渲染为字符串 -->
<p>{{ '<strong>hello</strong>' }}</p>

<!-- 渲染为 HTML -->
<p v-html="htmlContent"></p>
```

> 使用 `v-html` 时注意防止 XSS 攻击。

---

### 响应式基础

Vue 的 **响应式系统** 是其核心特性之一，能够让 **数据** 和 **视图** 保持同步。当数据变化时，视图会自动更新。

- **应用示例(Vu3)：**


``` vue
<script setup>
import { ref, onMounted } from 'vue'

onMounted(() => {
})

const count = ref(0);

function increment() {
  //js中用.value
  count.value++
}

const person = ref({
  name: 'Seven Chen',
  age: 28,
  child:{
    name: 'Little Seven Chen',
    age: 9,
  }
});

function incrementAge() {
  //js中用.value
  //包装在第一层
  person.value.age++
}

function incrementChildAge() {
  //js中用.value
  //包装在第一层
  person.value.child.age++
}

const personList = ref([
{
  name: 'SC',
  age: 30,
  child:[
  {
    name: 'LSC',
    age: 10,
  }]
},
{
  name: 'SCA',
  age: 31,
  child:[
  {
    name: 'LSCA1',
    age: 11,
  }]
}
])

function decreaseListAge(){
  personList.value.forEach(person => {
    person.age --
    if(person.child){
      person.child.forEach(child => {
        child.age--
      })
    }
  })
}

function incremenListtAge(){
  personList.value.forEach(person => {
    person.age ++
    if(person.child){
      person.child.forEach(child => {
        child.age++
      })
    }
  })
}

function removePerson(){
  personList.value.forEach(person => {
    if(person.child){
      person.child.pop()
    }
  })
}

function addPerson(){
  personList.value.forEach(person => {
    if(person.child){
      person.child.push({
        name: 'ADD',
        age: 11,
      })
    }
  })
}
</script>

<template>
  <el-card >
    <template #header>ref 创建响应式变量</template>
    
    <!-- template中用变量本身 -->
    <button @click="count--">-</button>
    <span style="margin: 0 10px;">{{count}}</span>
    <button @click="increment">+</button>
  </el-card>
  <br/>
  <el-card >
    <template #header>ref 创建响应式对象</template>
    
    <!-- template中用变量本身 -->

    <p>{{ person.name }}</p>
    <button @click="person.age--">-</button>
    <span style="margin: 0 10px;">{{ person.age }}</span>
    <button @click="incrementAge">+</button>

    <p>{{ person.child.name }}</p>
    <button @click="person.child.age--">-</button>
    <span style="margin: 0 10px;">{{ person.child.age }}</span>
    <button @click="incrementChildAge">+</button>
    <p>{{ person }}</p>
  </el-card>
  <br/>
  <el-card >
    <template #header>ref 创建响应式对象数组</template>
    
    <!-- template中用变量本身 -->
    <p>操作属性</p>
    <button @click="decreaseListAge">-</button>
    <button @click="incremenListtAge">+</button>
    <p>操作对象</p>
    <button @click="removePerson">-</button>
    <button @click="addPerson">+</button>
    <p>{{ personList }}</p>
  </el-card>
</template>


<style scoped>

</style>

```

::: warning 注意 
1. **vue 2或选项式风格只需要将数据放进data里即可：**
比如
   
``` vue
export default {
  data() {
    return {
      count: 1
    }
  },

  // `mounted` 是生命周期钩子，之后我们会讲到
  mounted() {
    // `this` 指向当前组件实例
    console.log(this.count) // => 1

    // 数据属性也可以被更改
    this.count = 2
  }
}
```

2. **新项目(Vue 3.2+)推荐使用 `<script setup>`替换`setup()`，旧项目只能使用 `setup()`**
``` vue
import { ref } from 'vue'

export default {
  // `setup` 是一个特殊的钩子，专门用于组合式 API。
  setup() {
    const count = ref(0)

    // 将 ref 暴露给模板
    return {
      count
    }
  }
}
```

| `<script setup>`功能       | 编译阶段做了什么                                                   |
| -------------------------- | ------------------------------------------------------------------ |
| 自动调用 `setup()`         | Vue 自动把你写的顶层变量、函数等封装进 `setup()` 中                |
| 自动 `return` 所有顶层绑定 | 所有变量/函数都自动暴露给模板，无需手动 `return`                   |
| 支持宏函数                 | 编译时识别 `defineProps`、`defineEmits`、`defineExpose` 等特殊语法 |
| 更好支持类型推导           | 尤其在 TypeScript 中，变量作用域明确，无需解构重赋值               |
| 模块提升                   | 顶层导入/定义提升出 `setup()`，避免重复创建对象                    |

3. **可以通过 shallow ref 来放弃深层响应性。对于浅层 ref，只有 .value 的访问会被追踪。用于避免对大型数据的响应性开销来优化性能、或者有外部库管理其内部状态的情况。**
4. **只有代理对象是响应式的，更改原始对象不会触发更新。因此，使用 Vue 的响应式系统的最佳实践是仅使用你声明对象的代理版本。**
``` js
  const raw = {}
  const proxy = reactive(raw)

  // 代理对象和原始对象不是全等的
  console.log(proxy === raw) // false

  const raw1 = {}
  const proxy1 = ref(raw1)

  // 代理对象和原始对象不是全等的
  console.log(proxy1 === raw1) // false 
  console.log(proxy1.value === raw1) // false 
```
5. **reactive() 的局限性**
   1. **只能用于对象类型 (对象、数组和如 Map、Set 这样的集合类型)。它不能持有如 string、number 或 boolean 这样的原始类型。**
   2. **不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失**
   > **ref 替换 .value: 本体不变（响应系统依然追踪）.value 被 Vue 响应式代理，替换后视图自动更新**

   > **reactive 替换整个变量：user = {...} 其实是给 user 变量赋了新值, 原有的响应式追踪对象已经断开，新值不是响应式的**

   > **如果必须使用 reactive，应修改属性而非替换对象**
    ``` js
    let replace1 = reactive({ count1: 0 })

    function replaceReactive() {
      replace1 = { summer: replaceCounter++ } // 旧引用失效，原有响应断裂
    }

    let replace2 =  ref({ count2: 0 })

    function replaceRef() {
      replace2.value =  { summer: replaceCounter++ }  // 没有问题，视图正常更新
    }
    ```
   3. **将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，将丢失响应性连接**
    > **无论是reactive还是ref，只要解构对象内部属性，拿到的都是值类型，因此所拿到的变量与原对象不再有关联。**

    > **如果需要结构后的变量具有响应式，使用"toRefs()"**

    > **ref解决 结构/解构响应性丢失 的问题是指以 ref为整体时保持响应式**

    ``` js
      const state = reactive({ count: 0 })
      // 当解构时，count 已经与 state.count 断开连接
      let { count } = state
      // 不会影响原始的 state
      count++
      // 该函数接收到的是一个普通的数字
      // 并且无法追踪 state.count 的变化
      // 我们必须传入整个对象以保持响应性
      callSomeFunction(state.count)
    ```

::: danger 官方推荐统一使用ref
:::

- **实现原理：**

Vue 2 和 Vue 3 的响应式系统实现原理有根本性区别，主要体现在：

* **Vue 2：基于 Object.defineProperty（运行时劫持）**
* **Vue 3：基于 Proxy（编译时可拓展的代理）**

---

- **Vue 2 响应式原理（基于 `Object.defineProperty`）**

  1. Vue 会递归遍历对象的每个属性
  2. 使用 `Object.defineProperty` 劫持每个属性的 getter 和 setter
  3. 在 getter 中收集依赖（Dep）
  4. 在 setter 中触发更新（通知 Watcher）

```mermaid
graph TD
  A[初始化 data] --> B[递归遍历对象属性]
  B --> C[使用 Object.defineProperty 设置 getter/setter]
  C --> D[用户访问属性 -> 调用 getter]
  D --> E[Dep 收集 Watcher]
  C --> F[用户设置属性 -> 调用 setter]
  F --> G[通知 Watcher 更新视图]
```

- **存在的问题：**

   * **只能监听属性，不支持数组索引或新增属性**
   * **深层对象要递归遍历所有字段，性能差**
   * **无法检测 `arr[0] = xxx` 或 `obj.newProp = 123`**

---

- **Vue 3 响应式原理（基于 `Proxy`）**
> 当 ref 的值是一个对象时，ref() 会在内部调用 reactive。
  1. 使用 `Proxy` 代理整个对象，而不是单个属性
  2. 在 `get` 拦截器中自动收集依赖
  3. 在 `set` 拦截器中自动触发更新
  4. 响应式追踪通过全局的 `effect()` 机制实现

```mermaid
graph TD
  A[reactive ] --> B[返回 Proxy 对象]
  B --> C[用户访问属性 -> 触发 get]
  C --> D[调用 track  收集依赖]
  B --> E[用户修改属性 -> 触发 set]
  E --> F[调用 trigger  通知更新]
```

- **优点：**

  * 支持 **数组索引、新增属性、删除属性等全部操作**
  * **惰性代理**（不递归）性能更好
  * 更好支持 Map、Set、WeakMap 等复杂数据结构

---

| 特性              | Vue 2 (`defineProperty`) | Vue 3 (`Proxy`)      |
| ----------------- | ------------------------ | -------------------- |
| 支持新增/删除属性 | ❌ 需要 Vue.set           | ✅ 原生支持           |
| 深度嵌套性能      | ❌ 初始化时全递归         | ✅ 惰性递归，按需劫持 |
| 支持数组索引响应  | ❌ 不完全                 | ✅ 完全支持           |
| 支持 Map/Set      | ❌ 不支持                 | ✅ 支持               |
| 数据追踪能力      | 一对多（Dep -> Watcher） | 多对多（targetMap）  |
| 实现方式          | 运行时遍历属性           | 编译期生成 Proxy     |

> Vue 3 在访问对象内部属性之前，不会递归劫持它的子对象。只有在你访问的时候才会代理它。

---

### 计算属性
计算属性是 Vue 提供的一种基于其响应式系统的特性，它允许我们根据已有的响应式数据声明式地计算出新的值，并在依赖项变更时自动更新结果。

> **只有依赖的数据发生改变时才会重新计算。**

- **应用示例(Vu3)**

``` vue
<template>
  <el-card >
    <template #header>基本用法</template>
    
    <!-- template中用变量本身 -->
    <p>姓：{{ lastName }}</p>
    <p>名：{{ firstName }}</p>
    <p>姓名(计算属性)：{{ fullName }}</p>
    <p>姓名(方法)：{{ (() => { return `${lastName} ${firstName} `})() }}</p>
    <el-button @click="generateName">随机生成姓名</el-button>
    
    <p>姓名(可写计算属性)：{{ fullNameWriteable }}</p>
    <el-button @click="generateFullName">随机生成姓名-写入计算属性</el-button>

    <p>姓名(生成记录)：{{ previousName }}</p>
  </el-card>
  <br/>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue';
import { fakerZH_CN as faker } from '@faker-js/faker'

const firstName = ref('')
const lastName = ref('')

const previousName = ref('')

onMounted(() => {
  firstName.value = faker.person.firstName() // 名
  lastName.value = faker.person.lastName()  // 姓
})

// 计算属性
const fullName = computed((previous) => {
  previousName.value = String(previous)
  return `${lastName.value} ${firstName.value} `
})

function generateName(){
  firstName.value = faker.person.firstName() // 名
  lastName.value = faker.person.lastName()  // 姓
}

const fullNameWriteable = computed({
  get(previous) {
    previousName.value = String(previous)
    return `${lastName.value} ${firstName.value}`
  },

  set(newValue) {
    // 注意：我们这里使用的是解构赋值语法
    [firstName.value, lastName.value] = String(newValue).split(' ')
  }
})

function generateFullName(){
  fullNameWriteable.value = `${faker.person.firstName()} ${faker.person.lastName()}`
}

</script>

<style scoped>

</style>
```

::: warning 注意
1. vue2 写法
``` vue
export default {
  data() {
    return {
      author: {
        name: 'John Doe',
        books: [
          'Vue 2 - Advanced Guide',
          'Vue 3 - Basic Guide',
          'Vue 4 - The Mystery'
        ]
      }
    }
  },
  computed: {
    // 一个计算属性的 getter
    publishedBooksMessage() {
      // `this` 指向当前组件实例
      return this.author.books.length > 0 ? 'Yes' : 'No'
    }
  }
}
```

2. 将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，不同之处在于计算属性值会基于其响应式依赖被缓存。
这也解释了为什么下面的计算属性永远不会更新，因为 Date.now() 并不是一个响应式依赖：
``` js
const now = computed(() => Date.now())
```
:::

---

### 条件渲染

条件渲染（Conditional Rendering） 是控制模板中元素是否显示的关键技术。它基于 JavaScript 表达式的真假值，动态地插入或移除 DOM 元素，从而实现灵活的界面交互。

- **应用示例(Vu3)**

``` vue
<template>
  <el-card >
    <template #header>v-if</template>
    
    <p v-if="loggedIn">欢迎回来！</p>
    <p v-else>请先登录。</p>
    <el-button @click="loggedIn = !loggedIn">切换登录状态</el-button>
  </el-card>
  <br/>
  <el-card >
    <template #header>v-show</template>
    
    <p v-show="toggle">这段话只是被 display:none 了</p>
    <el-button @click="toggle = !toggle">显示 / 隐藏</el-button>
  </el-card>
</template>

<script setup>
import { ref} from 'vue';

const loggedIn = ref(false)

const toggle = ref(true)

</script>

<style scoped>

</style>
```

::: warning v-if 与 v-show 的选择比较

| 对比点       | `v-if`                                 | `v-show`                                |
| ------------ | -------------------------------------- | --------------------------------------- |
| 渲染策略     | **按需创建/销毁** DOM 元素             | 创建一次，之后仅切换 `display`          |
| 初始渲染开销 | 较大（每次条件变更都重新渲染）         | 较小（始终存在）                        |
| 适合场景     | 频繁切换不建议，适合条件变化较少的内容 | 适合频繁切换可见性的内容（如 Tab 切换） |
| DOM 保留状态 | 被销毁，状态丢失                       | 状态保留                                |

:::

::: danger 注意
1. 不能同时使用 v-if 和 v-for 在同一元素上
> 可读性差，容易误解优先级。会误认为先判断 v-if 再遍历。实际是先遍历，再判断是否渲染。
``` html
<!-- 不推荐 -->
<li v-for="item in list" v-if="item.visible">{{ item.name }}</li>

<!-- 推荐方式 -->
<li v-for="item in list" v-show="item.visible">{{ item.name }}</li>
<!-- 或者 -->

const visibleItems = computed(() => list.value.filter(item => item.visible))

```

2. v-else 和 v-else-if 必须紧跟 v-if 元素
3. v-show 不影响 v-if 的渲染逻辑
:::

### 列表渲染

### 事件处理

### 表单输入绑定

### 侦听器

### 模板引用

## 组件

## 逻辑复用

## 应用规模化

## vuex

## vue-router

## Element-UI