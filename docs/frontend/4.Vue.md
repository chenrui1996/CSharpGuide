# Vue

## 介绍

`Vue` 是一款用于构建用户界面的 ***渐进式*** `JavaScript` 框架。它基于标准 `HTML` `CSS` 和 `JavaScript` 构建，并提供了一套 ***声明式*** 的、***组件化*** 的编程模型，帮助你高效地开发用户界面。

::: tip 声明

`Vue` 有极其完备的文档：https://cn.vuejs.org/

根据文档可以快速上手，解决问题，集成生态。

本文档仅从个人角度介绍 `Vue` 的常见应用与问题, 文档demo仓库：https://github.com/chenrui1996/vue-demo。

，详细文档请参考官网。

:::

::: warning 渐进式框架
`Vue` 是一个框架，也是一个生态。其功能覆盖了大部分前端开发常见的需求。

但 Web 世界是十分多样化的，不同的开发者在 Web 上构建的东西可能在形式和规模上会有很大的不同。

考虑到这一点，Vue 的设计非常注重灵活性和“可以被逐步集成”这个特点。

根据你的需求场景，你可以用不同的方式使用 `Vue`：

- 无需构建步骤，渐进式增强**静态**的 `HTML`.
- 在任何页面中作为 `Web Components` 嵌入
- **单页应用 (SPA)**
- **全栈 / 服务端渲染 (SSR)**
- **Jamstack / 静态站点生成 (SSG)**
- **开发桌面端、移动端、WebGL，甚至是命令行终端中的界面**
:::

::: warning 常见前端渲染方式
| 渲染方式            | 简介                                                           | 应用场景示例                                                             |
| ------------------- | -------------------------------------------------------------- | ------------------------------------------------------------------------ |
| SSR（服务端渲染）   | 页面 HTML 在服务器生成，浏览器接收到完整 HTML 再显示           | Razor Pages、Blazor Server                                               |
| CSR（客户端渲染）   | 后端仅返回数据，页面结构和渲染逻辑在浏览器中由 JavaScript 执行 | Vue/React SPA                                                            |
| SSG（静态站点生成） | 编译时生成静态 HTML，部署时直接提供                            | [Nuxt 静态模式](https://nuxt.com/)、[Jekyll](https://www.jekyll.com.cn/) |
| ISR（增量静态生成） | 静态页面支持按需重新生成，结合 SSG 与 SSR 的优点               | [Next.js](https://nextjs.org/) ISR 模式                                  |
| 混合渲染（Hybrid）  | 某些页面 SSR，某些页面 CSR，结合使用                           | [Nuxt](https://nuxt.com/)、[Next.js](https://nextjs.org/) 支持按路由配置 |
| Prerender（预渲染） | 构建阶段预先执行 JS，生成 HTML 快照                            | Vue Prerender 插件                                                       |

:::

::: danger vue2 与 vue3
1. Vue 2 已在 2023 年 12 月 31 日到达它的截止维护日期。在此之后，Vue 2 在已有的分发渠道 (各类 CDN 和包管理器) 中仍然可用，**但不再进行更新，包括对安全问题和浏览器兼容性问题的修复等。**
2. 大部分 Vue 3 重要的特性移植回了 Vue 2.7，包括组合式 API 和 `<script setup>`。如果打算留在 Vue 2，应该至少升级至 2.7。
3. Vue 2 升级到vue3参考 [vue3迁移指南](https://v3-migration.vuejs.org/zh/breaking-changes/key-attribute.html)
4. Vue 3 提供了更小的包体积、更好的性能、更好的可扩展性和更好的 TypeScript/IDE 支持。但Vue 3 用到了一些 IE11 不支持的现代 JavaScript 特性。
5. vue 3 相对vue 2的优化
   1. Vue 3 重写了虚拟 DOM，使其更快、更轻量，内存占用更低。Patch 过程更高效，diff 算法更智能。
   2. Vue 3 使用模块化架构，支持 `Tree-shaking`，打包时可以剔除未使用的功能，减小体积。
   3. 核心库比 Vue 2 更轻量（压缩后约 10KB 左右，比 Vue 2 小约 50%）。
   4. 编译器能更好地标记静态节点，减少运行时开销。
   5. Vue 3 使用 `Proxy` 代替 vue 2中的 `Object.defineProperty`（无法监听数组索引、新增属性等） 实现响应式，能监听几乎所有操作，包括新增、删除、嵌套属性变更等。
   6. `Composition API` 替代 `Options API` 的局限性。
   7. Vue 3 重写代码为 TypeScript，原生支持，开发体验更好。
   8. ref, `reactive`, `computed`, `watch`, `watchEffect` 等新的响应式工具函数。`provide` / `inject` 更适合逻辑复用。
:::

## 创建应用

### 准备工作

::: warning node.js
[Node.js](https://nodejs.org/zh-cn) 是一个免费、开源、跨平台的 `JavaScript` 运行时环境, 

它允许开发者在**服务器端**使用 `JavaScript` 编写应用程序，从而实现前后端统一的开发语言。

---

- **核心特点**
  - 事件驱动与非阻塞 I/O：Node.js 采用单线程架构，结合事件循环机制和异步 I/O 操作，能够高效地处理大量并发连接，适用于 I/O 密集型应用，如 Web 服务器和实时通信工具。 
  - 高性能：得益于 V8 引擎的优化，Node.js 在执行 JavaScript 代码时表现出色，适合构建高性能的网络应用。
  - 丰富的生态系统：通过内置的 npm（Node Package Manager），开发者可以方便地安装和管理第三方模块，加速开发流程。 
  - 跨平台支持：Node.js 可在 Windows、Linux 和 macOS 等多个操作系统上运行，适应多样化的部署需求。

---

- **`Vue` 中为什么要使用 `node.js`**

  **1. 开发工具链依赖 Node.js**
    - Vue CLI / Vite：官方脚手架工具（如 Vue CLI 或 Vite）需要 Node.js 环境来初始化项目、管理依赖和运行开发服务器。
    - 热重载（HMR）：开发时的模块热更新依赖 Node.js 提供的本地服务器能力。
    - 构建工具：webpack、Rollup 或 Vite 等工具需要 Node.js 执行代码打包、压缩、转译等操作

  **2. npm/yarn/pnpm 包管理**
     - Vue 生态系统的大量第三方库（如 vue-router、pinia、axios）通过 npm/yarn 安装，这些工具基于 Node.js。

  **3. 前端工程化需求**
     - 模块化开发：Node.js 支持 ES Modules/CommonJS，方便组织现代前端代码。
     - 编译转换：Vue 单文件组件（.vue）需要 vue-loader 或 @vitejs/plugin-vue 转译为浏览器可执行的 JS，这需要 Node.js 环境。
     - 预处理语言：Sass/Less/TypeScript 等需通过 Node.js 工具链编译。

  **4. 服务端渲染（SSR）**
     - 使用 Nuxt.js 或直接配置 Vue SSR 时，需要 Node.js 作为服务器渲染 Vue 组件并返回 HTML，提升首屏性能和 SEO。

  **5. API 代理与 Mock 数据**
     - 开发时可通过 Node.js 服务器代理 API 请求，解决跨域问题（如 vite.config.js 中的 proxy 配置）。
     - 使用 Mock.js 等工具模拟后端接口。

  **6. 自动化与脚本**
     - 通过 Node.js 编写脚本处理重复任务（如批量生成组件、部署前优化等）。
---

- **可不可以不用 Node.js**
  - 直接引入：直接下载最新版本，通过 `<script>` 标签引入 `Vue`，或直接引入 `CDN`， 适合简单页面或学习，但无法享受工程化优势。
  - 静态生成：使用 Vue 构建纯静态站点（如通过 vitepress）后，生产环境只需静态服务器（如 Nginx）。

---


:::

::: tip webpack
[Webpack](https://webpack.js.org/) 是一个功能强大的前端构建工具和模块打包器，广泛应用于现代 JavaScript 应用程序的开发中。

它能够将项目中的各种资源（如 JavaScript、CSS、图片等）视为模块，构建出清晰的依赖关系图，并将这些模块打包成可供浏览器使用的静态文件。

---

- 核心概念

  1. 入口（Entry）

  入口指示 Webpack 应该从哪个模块开始构建依赖图。默认情况下，Webpack 会从 `./src/index.js` 作为入口。

  ```javascript
  module.exports = {
    entry: './src/index.js',
  };
  ```

  对于多页面应用，可以指定多个入口点。

  2. 输出（Output）

  输出配置告诉 Webpack 如何命名和存储打包后的文件。

  ```javascript
  module.exports = {
    output: {
      filename: 'bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
  };
  ```

  `filename` 指定输出文件的名称，`path` 指定输出目录的绝对路径。

  3. 加载器（Loaders）

  加载器使 Webpack 能够处理非 JavaScript 文件，如 CSS、图片等。它们在模块加载时进行转换，使这些资源能够被添加到依赖图中。

  ```javascript
  module.exports = {
    module: {
      rules: [
        {
          test: /\.css$/,
          use: ['style-loader', 'css-loader'],
        },
      ],
    },
  };
  ```

  上述配置允许 Webpack 处理 `.css` 文件，并将其注入到 JavaScript 中。

  4. 插件（Plugins）

  插件用于执行范围更广的任务，如打包优化、资源管理、环境变量注入等。

  ```javascript
  const HtmlWebpackPlugin = require('html-webpack-plugin');

  module.exports = {
    plugins: [
      new HtmlWebpackPlugin({ template: './src/index.html' }),
    ],
  };
  ```
  `HtmlWebpackPlugin` 插件会根据提供的模板生成一个 HTML 文件，并自动引入打包后的资源。

  5. 模式（Mode）

  Webpack 提供了三种模式：`development`、`production` 和 `none`。设置不同的模式会启用相应的优化。

  ```javascript
  module.exports = {
    mode: 'development', // 或 'production'、'none'
  };
  ```

  * `development`：启用有利于开发的设置，如未压缩的输出和详细的错误信息。
  * `production`：启用优化设置，如代码压缩和性能提升。

---
:::

::: tip Vue CLI（基于 Webpack）
Vue CLI（Command Line Interface）是 Vue.js 官方提供的脚手架工具，旨在帮助开发者快速搭建和管理 Vue 项目。

> Vue CLI 现已处于维护模式!
> 现在官方推荐使用 create-vue 来创建基于 Vite 的新项目。 另外请参考 Vue 3 工具链指南 以了解最新的工具推荐。

[官网](https://cli.vuejs.org/zh/)

:::

::: warning Vite
Vite 是一个现代化的前端构建工具，于 2020 年发布，旨在通过利用现代浏览器的原生 ES 模块支持，提供快速的开发体验。

[官网](https://cn.vite.dev/), [为什么选 Vite](https://cn.vite.dev/guide/why.html)

:::

### 创建一个 Vue 应用

[官网文档](https://cn.vuejs.org/guide/quick-start)

- **需要安装 Node.js**

> **若本地需要多个版本的Node.js，可以使用 [NVM](https://github.com/coreybutler/nvm-windows) 管理**

**Vue 和 Node.js 版本**

| Vue 版本 | 推荐 Node.js 版本 | 构建工具建议        | 生命周期状态 |
| -------- | ----------------- | ------------------- | ------------ |
| Vue 2.x  | 10 – 16           | Vue CLI 4.x         | 已停止维护   |
| Vue 3.x  | 18.3 及以上       | Vite / Vue CLI 4.5+ | 活跃维护中   |

- **需要安装 `create-vue`(默认集成了 `Vite` 作为构建工具的 `Vue` 官方提供的脚手架工具)**
 
> **如未安装建议全局安装`npm install -g  create-vue@latest`**

---

#### 创建步骤

1. **运行以下命令**
``` sh
npm create vue@latest
```

  **可选功能提示：**

``` sh
◇  请输入项目名称：
│  vue-demo
│
◆  请选择要包含的功能： (↑/↓ 切换，空格选择，a 全选，回车确认)
│  ◻ TypeScript
│  ◻ JSX 支持
│  ◻ Router（单页面应用开发）
│  ◻ Pinia（状态管理）
│  ◻ Vitest（单元测试）
│  ◻ 端到端测试
│  ◻ ESLint（错误预防）
│  ◻ Prettier（代码格式化）
```

2. **安装依赖**
``` sh
cd <your-project-name>
npm install
```

3. **启动开发服务器**
``` sh
cd <your-project-name>
npm run dev
```

4. **发布到生产环境**

``` sh
npm run build
```

---

#### 目录结构分析

```bash
my-vue-app/
├── node_modules/
├── public/
│   ├── favicon.ico
│   └── index.html
├── src/
│   ├── assets/
│   ├── components/
│   ├── App.vue
│   └── main.js
├── .gitignore
├── babel.config.js
├── package.json
├── README.md
└── vue.config.js (可选)
```

1. **`node_modules/`**

* 自动生成的依赖文件夹，存放项目用到的所有 npm 包。
* **不需要手动更改内容，通常不提交到 Git 仓库。**

2. **`public/`**

* 存放静态资源，打包时内容**原样拷贝**到最终的构建目录 (`dist`)。

| 文件/目录     | 说明                                                                                     |
| ------------- | ---------------------------------------------------------------------------------------- |
| `index.html`  | 入口 HTML 模板，Vue 应用会挂载在这里的 `<div id="app"></div>` 中。你可以自定义头部内容。 |
| `favicon.ico` | 网站图标，可替换。                                                                       |

3. **`src/`**

* 项目源码目录，是开发的主要区域。

| 文件/目录     | 说明                                                                       |
| ------------- | -------------------------------------------------------------------------- |
| `main.js`     | 应用入口文件，创建 Vue 实例并挂载到 `#app`。通常在此注册全局组件、插件等。 |
| `App.vue`     | 根组件，通常作为整个应用的框架壳，里面包含 `<router-view>` 或页面结构。    |
| `components/` | 存放 Vue 单文件组件（`.vue`），如按钮、表单、模块等 UI 单元组件。          |
| `assets/`     | 存放静态资源，如图片、字体等，会被 Webpack 处理（例如 hash 命名）。        |

* 若启用 Vue Router / Vuex，CLI 可能还会添加这些目录：

| 目录      | 用途                                                 |
| --------- | ---------------------------------------------------- |
| `views/`  | 路由页面组件（每个页面一个 `.vue` 文件）             |
| `router/` | Vue Router 配置文件，通常是 `index.js`，包含路由表。 |
| `store/`  | Vuex 状态管理目录。                                  |

4. **配置文件**

| 文件名            | 作用                                                     |
| ----------------- | -------------------------------------------------------- |
| `.gitignore`      | 配置 Git 忽略哪些文件（如 `node_modules/`）              |
| `package.json`    | 描述项目及依赖、脚本等信息。最核心的项目配置文件。       |
| `babel.config.js` | Babel 配置，用于转译 JavaScript 新语法。                 |
| `vue.config.js`   | Vue CLI 配置文件，可配置打包路径、代理、Webpack 设置等。 |
| `README.md`       | 项目说明文档，可填写使用方法、目录说明、运行步骤等。     |

---

#### 运行过程

> 在 Web 服务器中（如 Apache、Nginx、Vite 的 dev server），访问目录时会默认查找 index.html 作为入口文件。

``` mermaid
graph TD
    A[运行 npm run dev] --> B[Vite 启动开发服务器]
    B --> C[读取 index.html]
    C --> D[查找并执行 main.js]
    D --> E[main.js 创建 Vue 实例]
    E --> F[加载 App.vue]
    F --> G[App.vue 渲染并挂载到 #app]
    G --> H[Vue 应用开始运行]

```

---

#### 构建过程

``` mermaid
graph TD
    A[运行 npm run build] --> B[Vite 读取 vite.config.js]
    B --> C[解析 public/index.html]
    C --> D[找到入口文件 main.js]
    D --> E[Rollup 递归分析依赖]
    E --> F[代码分割 & Tree shaking]
    F --> G[应用插件 压缩、转换 ]
    G --> H[生成构建输出文件  dist/ ]
    H --> I[构建完成，可部署]

```

## 基础

### 模板语法

`Vue` 使用一种基于 `HTML` 的模板语法，使我们能够**声明式**地将其组件**实例的数据** **绑定**到呈现的 `DOM` 上。
> 所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。

在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。

结合**响应式系统**，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。

| 功能         | 语法                            |
| ------------ | ------------------------------- |
| 插值         | `{ { message } }`               |
| 属性绑定     | `:href="url"`                   |
| 事件绑定     | `@click="handleClick"`          |
| 双向数据绑定 | `v-model="message"`             |
| 动态 class   | `:class="{ active: isActive }"` |
| 动态 style   | `:style="{ color: textColor }"` |

- **应用示例：**

``` vue
<script setup>
import { ref } from 'vue'

const message = ref('Hello Vue!')
const url = ref('https://vuejs.org')
const isVisible = ref(true)
const items = ref(['苹果', '香蕉', '橘子'])
const isActive = ref(true)
const textColor = ref('blue')

function handleClick() {
  alert('按钮被点击了！')
}
</script>

<template>
  <!-- 插值语法 -->
  <h1>{{ message }}</h1>

  <!-- 双向绑定 -->
  <input v-model="message" placeholder="修改 message" />

  <hr/>

  <!-- 属性绑定 -->
  <a :href="url" target="_blank">访问链接</a>

  <hr/>
  <!-- 条件渲染 -->
  <input v-model="isVisible" type="checkbox" />

  <p v-if="isVisible" style="display: inline-block;">这个段落是可见的。</p>
  <p v-else style="display: inline-block;">这个段落是不可见的。</p>

  <hr/>

  <!-- 列表渲染 -->
  <ul>
    <li v-for="(item, index) in items" :key="index">
      {{ index + 1 }} - {{ item }}
    </li>
  </ul>

  <hr/>

  <!-- 事件处理 -->
  <button v-on:click="handleClick">点击我</button>
  <button @click="handleClick">点击我</button>

  <hr/>

  <!-- 绑定 class 和 style -->
  <!-- 插值语法不起作用，插值语法不会被当作属性解析 -->
  <p :class="{ active: isActive }" :style="{ color: textColor }">
    动态 class 和 style 示例
  </p>
</template>

<style lang="sass" scoped>

</style>
```

---

- **渲染流程**

``` mermaid
graph TD
  A[模板 template] --> B[编译器 compiler]
  B --> C[渲染函数 render function]
  C --> D[虚拟 DOM VNode]
  D --> E[真实 DOM 初次渲染]

  subgraph 响应式更新流程
    F[响应式数据改变] --> G[依赖追踪触发更新]
    G --> C
    C --> D2[新的 VNode]
    D2 --> H[Diff 对比新旧 VNode]
    H --> I[Patch 更新 DOM]
  end

  E --> F

```

---

1. **模板编译**

在开发时，你写的：

```html
<h1>{{ message }}</h1>
```

Vue 编译器会将其转换为类似这样的 JavaScript 渲染函数（伪代码）：

```js
function render(ctx) {
  return h('h1', null, ctx.message)
}
```

* `h()` 是 Vue 创建虚拟 DOM 的函数（Hyperscript）
* `ctx` 是组件实例的上下文，里面包含了 `message`

> ⚠️ 注意：Vue 3 的模板在构建阶段由 `@vue/compiler-dom` 预编译成 `render` 函数，这样运行时就更高效。

---

2. **响应式绑定（Reactivity）**

Vue 使用响应式系统（基于 `Proxy`）追踪依赖：

```js
const message = ref('Hello')
```

当组件第一次渲染时，Vue 会把 `message` 读取过程记录为依赖。

当你修改它：

```js
message.value = 'Hi'
```

Vue 会触发对应的渲染函数再次执行，生成新的 **VNode 树（虚拟 DOM）**。

---

3. **虚拟 DOM 比较（Diff）和 Patch**

每次响应式数据变动时，Vue 会：

1. 使用新的数据生成新的虚拟 DOM（VNode）
2. 与旧的虚拟 DOM 进行 diff 比较
3. 通过最小化更新操作，**打补丁**到真实 DOM 上（patch）

> 优点：性能高，不需要完全重新渲染 DOM，只更新变动的部分。

---

- **注意事项**

1. **插值语法不能用于 HTML 属性**

```html
<!-- 错误 -->
<a href="{{ url }}">点击</a> <!-- 不会解析 -->

<!-- 正确 -->
<a :href="url">点击</a>
```

插值 `{{ }}` 只能用于元素内容，不能用于属性。

---

2.  **`v-bind` 简写为 `:`，`v-on` 简写为 `@`**

```html
<!-- 完整写法 -->
<img v-bind:src="imageUrl">
<button v-on:click="submit">提交</button>

<!-- 推荐写法 -->
<img :src="imageUrl">
<button @click="submit">提交</button>
```

---

3.  **模板中不能使用 JavaScript 语句**

```html
<!-- 错误 -->
<p>{{ if (ok) { return 'yes' } }}</p>

<!-- 正确（表达式可以） -->
<p>{{ ok ? 'yes' : 'no' }}</p>
```

> 只能写**表达式**，不能写完整语句（如 if、for、while、return 等）。

---

4. **双向绑定 (`v-model`) 只能用于表单元素**

```html
<!-- 正确 -->
<input v-model="username" />

<!-- 错误 -->
<!-- v-model 不能用在 <div>、<p> 等非表单元素上 -->
<div v-model="username"></div>
```

---

5. **绑定 class/style 推荐使用对象或数组语法**

```html
<!-- 推荐 -->
<p :class="{ active: isActive }"></p>
<p :style="{ color: textColor }"></p>

<!-- 不推荐 -->
<p class="{{ isActive ? 'active' : '' }}"></p> <!-- 无效 -->
```

---

6. **根节点只能有一个（在 Vue 2）**

* Vue 2：模板只能有一个根元素（如 `<div>`）
* Vue 3：允许多个根节点

---

7. **HTML 会被自动转义，除非使用 `v-html`**

```html
<!-- 渲染为字符串 -->
<p>{{ '<strong>hello</strong>' }}</p>

<!-- 渲染为 HTML -->
<p v-html="htmlContent"></p>
```

> 使用 `v-html` 时注意防止 XSS 攻击。

---

### 响应式基础

Vue 的 **响应式系统** 是其核心特性之一，能够让 **数据** 和 **视图** 保持同步。当数据变化时，视图会自动更新。

- **应用示例(Vu3)：**


``` vue
<script setup>
import { ref, onMounted } from 'vue'

onMounted(() => {
})

const count = ref(0);

function increment() {
  //js中用.value
  count.value++
}

const person = ref({
  name: 'Seven Chen',
  age: 28,
  child:{
    name: 'Little Seven Chen',
    age: 9,
  }
});

function incrementAge() {
  //js中用.value
  //包装在第一层
  person.value.age++
}

function incrementChildAge() {
  //js中用.value
  //包装在第一层
  person.value.child.age++
}

const personList = ref([
{
  name: 'SC',
  age: 30,
  child:[
  {
    name: 'LSC',
    age: 10,
  }]
},
{
  name: 'SCA',
  age: 31,
  child:[
  {
    name: 'LSCA1',
    age: 11,
  }]
}
])

function decreaseListAge(){
  personList.value.forEach(person => {
    person.age --
    if(person.child){
      person.child.forEach(child => {
        child.age--
      })
    }
  })
}

function incremenListtAge(){
  personList.value.forEach(person => {
    person.age ++
    if(person.child){
      person.child.forEach(child => {
        child.age++
      })
    }
  })
}

function removePerson(){
  personList.value.forEach(person => {
    if(person.child){
      person.child.pop()
    }
  })
}

function addPerson(){
  personList.value.forEach(person => {
    if(person.child){
      person.child.push({
        name: 'ADD',
        age: 11,
      })
    }
  })
}
</script>

<template>
  <el-card >
    <template #header>ref 创建响应式变量</template>
    
    <!-- template中用变量本身 -->
    <button @click="count--">-</button>
    <span style="margin: 0 10px;">{{count}}</span>
    <button @click="increment">+</button>
  </el-card>
  <br/>
  <el-card >
    <template #header>ref 创建响应式对象</template>
    
    <!-- template中用变量本身 -->

    <p>{{ person.name }}</p>
    <button @click="person.age--">-</button>
    <span style="margin: 0 10px;">{{ person.age }}</span>
    <button @click="incrementAge">+</button>

    <p>{{ person.child.name }}</p>
    <button @click="person.child.age--">-</button>
    <span style="margin: 0 10px;">{{ person.child.age }}</span>
    <button @click="incrementChildAge">+</button>
    <p>{{ person }}</p>
  </el-card>
  <br/>
  <el-card >
    <template #header>ref 创建响应式对象数组</template>
    
    <!-- template中用变量本身 -->
    <p>操作属性</p>
    <button @click="decreaseListAge">-</button>
    <button @click="incremenListtAge">+</button>
    <p>操作对象</p>
    <button @click="removePerson">-</button>
    <button @click="addPerson">+</button>
    <p>{{ personList }}</p>
  </el-card>
</template>


<style scoped>

</style>

```

::: warning 注意 
1. **vue 2或选项式风格只需要将数据放进data里即可：**
比如
   
``` vue
export default {
  data() {
    return {
      count: 1
    }
  },

  // `mounted` 是生命周期钩子，之后我们会讲到
  mounted() {
    // `this` 指向当前组件实例
    console.log(this.count) // => 1

    // 数据属性也可以被更改
    this.count = 2
  }
}
```

2. **新项目(Vue 3.2+)推荐使用 `<script setup>`替换`setup()`，旧项目只能使用 `setup()`**
``` vue
import { ref } from 'vue'

export default {
  // `setup` 是一个特殊的钩子，专门用于组合式 API。
  setup() {
    const count = ref(0)

    // 将 ref 暴露给模板
    return {
      count
    }
  }
}
```

| `<script setup>`功能       | 编译阶段做了什么                                                   |
| -------------------------- | ------------------------------------------------------------------ |
| 自动调用 `setup()`         | Vue 自动把你写的顶层变量、函数等封装进 `setup()` 中                |
| 自动 `return` 所有顶层绑定 | 所有变量/函数都自动暴露给模板，无需手动 `return`                   |
| 支持宏函数                 | 编译时识别 `defineProps`、`defineEmits`、`defineExpose` 等特殊语法 |
| 更好支持类型推导           | 尤其在 TypeScript 中，变量作用域明确，无需解构重赋值               |
| 模块提升                   | 顶层导入/定义提升出 `setup()`，避免重复创建对象                    |

3. **可以通过 shallow ref 来放弃深层响应性。对于浅层 ref，只有 .value 的访问会被追踪。用于避免对大型数据的响应性开销来优化性能、或者有外部库管理其内部状态的情况。**
4. **只有代理对象是响应式的，更改原始对象不会触发更新。因此，使用 Vue 的响应式系统的最佳实践是仅使用你声明对象的代理版本。**
``` js
  const raw = {}
  const proxy = reactive(raw)

  // 代理对象和原始对象不是全等的
  console.log(proxy === raw) // false

  const raw1 = {}
  const proxy1 = ref(raw1)

  // 代理对象和原始对象不是全等的
  console.log(proxy1 === raw1) // false 
  console.log(proxy1.value === raw1) // false 
```
5. **reactive() 的局限性**
   1. **只能用于对象类型 (对象、数组和如 Map、Set 这样的集合类型)。它不能持有如 string、number 或 boolean 这样的原始类型。**
   2. **不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失**
   > **ref 替换 .value: 本体不变（响应系统依然追踪）.value 被 Vue 响应式代理，替换后视图自动更新**

   > **reactive 替换整个变量：user = {...} 其实是给 user 变量赋了新值, 原有的响应式追踪对象已经断开，新值不是响应式的**

   > **如果必须使用 reactive，应修改属性而非替换对象**
    ``` js
    let replace1 = reactive({ count1: 0 })

    function replaceReactive() {
      replace1 = { summer: replaceCounter++ } // 旧引用失效，原有响应断裂
    }

    let replace2 =  ref({ count2: 0 })

    function replaceRef() {
      replace2.value =  { summer: replaceCounter++ }  // 没有问题，视图正常更新
    }
    ```
   3. **将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，将丢失响应性连接**
    > **无论是reactive还是ref，只要解构对象内部属性，拿到的都是值类型，因此所拿到的变量与原对象不再有关联。**

    > **如果需要结构后的变量具有响应式，使用"toRefs()"**

    > **ref解决 结构/解构响应性丢失 的问题是指以 ref为整体时保持响应式**

    ``` js
      const state = reactive({ count: 0 })
      // 当解构时，count 已经与 state.count 断开连接
      let { count } = state
      // 不会影响原始的 state
      count++
      // 该函数接收到的是一个普通的数字
      // 并且无法追踪 state.count 的变化
      // 我们必须传入整个对象以保持响应性
      callSomeFunction(state.count)
    ```

::: danger reactive 与 ref 如何选择
> **reactive 替换对象会丧失响应式（新对象如果不是响应式可能会存在问题），ref 监听时默认不开启深度监听**
> 
> **两个都不是严重的缺陷，建议统一使用规范。要么对象都用reactive（对 对象属性重新赋值），值都用ref；要么都用ref（watch时开启深度监听）。**
:::

- **实现原理：**

Vue 2 和 Vue 3 的响应式系统实现原理有根本性区别，主要体现在：

* **Vue 2：基于 Object.defineProperty（运行时劫持）**
* **Vue 3：基于 Proxy（编译时可拓展的代理）**

---

- **Vue 2 响应式原理（基于 `Object.defineProperty`）**

  1. Vue 会递归遍历对象的每个属性
  2. 使用 `Object.defineProperty` 劫持每个属性的 getter 和 setter
  3. 在 getter 中收集依赖（Dep）
  4. 在 setter 中触发更新（通知 Watcher）

```mermaid
graph TD
  A[初始化 data] --> B[递归遍历对象属性]
  B --> C[使用 Object.defineProperty 设置 getter/setter]
  C --> D[用户访问属性 -> 调用 getter]
  D --> E[Dep 收集 Watcher]
  C --> F[用户设置属性 -> 调用 setter]
  F --> G[通知 Watcher 更新视图]
```

- **存在的问题：**

   * **只能监听属性，不支持数组索引或新增属性**
   * **深层对象要递归遍历所有字段，性能差**
   * **无法检测 `arr[0] = xxx` 或 `obj.newProp = 123`**

---

- **Vue 3 响应式原理（基于 `Proxy`）**
> 当 ref 的值是一个对象时，ref() 会在内部调用 reactive。
  1. 使用 `Proxy` 代理整个对象，而不是单个属性
  2. 在 `get` 拦截器中自动收集依赖
  3. 在 `set` 拦截器中自动触发更新
  4. 响应式追踪通过全局的 `effect()` 机制实现

```mermaid
graph TD
  A[reactive ] --> B[返回 Proxy 对象]
  B --> C[用户访问属性 -> 触发 get]
  C --> D[调用 track  收集依赖]
  B --> E[用户修改属性 -> 触发 set]
  E --> F[调用 trigger  通知更新]
```

- **优点：**

  * 支持 **数组索引、新增属性、删除属性等全部操作**
  * **惰性代理**（不递归）性能更好
  * 更好支持 Map、Set、WeakMap 等复杂数据结构

---

| 特性              | Vue 2 (`defineProperty`) | Vue 3 (`Proxy`)      |
| ----------------- | ------------------------ | -------------------- |
| 支持新增/删除属性 | ❌ 需要 Vue.set           | ✅ 原生支持           |
| 深度嵌套性能      | ❌ 初始化时全递归         | ✅ 惰性递归，按需劫持 |
| 支持数组索引响应  | ❌ 不完全                 | ✅ 完全支持           |
| 支持 Map/Set      | ❌ 不支持                 | ✅ 支持               |
| 数据追踪能力      | 一对多（Dep -> Watcher） | 多对多（targetMap）  |
| 实现方式          | 运行时遍历属性           | 编译期生成 Proxy     |

> Vue 3 在访问对象内部属性之前，不会递归劫持它的子对象。只有在你访问的时候才会代理它。

---

### 计算属性
计算属性是 Vue 提供的一种基于其响应式系统的特性，它允许我们根据已有的响应式数据声明式地计算出新的值，并在依赖项变更时自动更新结果。

> **只有依赖的数据发生改变时才会重新计算。**

- **应用示例(Vu3)**

``` vue
<template>
  <el-card >
    <template #header>基本用法</template>
    
    <!-- template中用变量本身 -->
    <p>姓：{{ lastName }}</p>
    <p>名：{{ firstName }}</p>
    <p>姓名(计算属性)：{{ fullName }}</p>
    <p>姓名(方法)：{{ (() => { return `${lastName} ${firstName} `})() }}</p>
    <el-button @click="generateName">随机生成姓名</el-button>
    
    <p>姓名(可写计算属性)：{{ fullNameWriteable }}</p>
    <el-button @click="generateFullName">随机生成姓名-写入计算属性</el-button>

    <p>姓名(生成记录)：{{ previousName }}</p>
  </el-card>
  <br/>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue';
import { fakerZH_CN as faker } from '@faker-js/faker'

const firstName = ref('')
const lastName = ref('')

const previousName = ref('')

onMounted(() => {
  firstName.value = faker.person.firstName() // 名
  lastName.value = faker.person.lastName()  // 姓
})

// 计算属性
const fullName = computed((previous) => {
  previousName.value = String(previous)
  return `${lastName.value} ${firstName.value} `
})

function generateName(){
  firstName.value = faker.person.firstName() // 名
  lastName.value = faker.person.lastName()  // 姓
}

const fullNameWriteable = computed({
  get(previous) {
    previousName.value = String(previous)
    return `${lastName.value} ${firstName.value}`
  },

  set(newValue) {
    // 注意：我们这里使用的是解构赋值语法
    [firstName.value, lastName.value] = String(newValue).split(' ')
  }
})

function generateFullName(){
  fullNameWriteable.value = `${faker.person.firstName()} ${faker.person.lastName()}`
}

</script>

<style scoped>

</style>
```

::: warning 注意
1. vue2 写法
``` vue
export default {
  data() {
    return {
      author: {
        name: 'John Doe',
        books: [
          'Vue 2 - Advanced Guide',
          'Vue 3 - Basic Guide',
          'Vue 4 - The Mystery'
        ]
      }
    }
  },
  computed: {
    // 一个计算属性的 getter
    publishedBooksMessage() {
      // `this` 指向当前组件实例
      return this.author.books.length > 0 ? 'Yes' : 'No'
    }
  }
}
```

2. 将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，不同之处在于计算属性值会基于其响应式依赖被缓存。
这也解释了为什么下面的计算属性永远不会更新，因为 Date.now() 并不是一个响应式依赖：
``` js
const now = computed(() => Date.now())
```
:::

---

### 条件渲染

条件渲染（Conditional Rendering） 是控制模板中元素是否显示的关键技术。它基于 JavaScript 表达式的真假值，动态地插入或移除 DOM 元素，从而实现灵活的界面交互。

- **应用示例(Vu3)**

``` vue
<template>
  <el-card >
    <template #header>v-if</template>
    
    <p v-if="loggedIn">欢迎回来！</p>
    <p v-else>请先登录。</p>
    <el-button @click="loggedIn = !loggedIn">切换登录状态</el-button>
  </el-card>
  <br/>
  <el-card >
    <template #header>v-show</template>
    
    <p v-show="toggle">这段话只是被 display:none 了</p>
    <el-button @click="toggle = !toggle">显示 / 隐藏</el-button>
  </el-card>
</template>

<script setup>
import { ref} from 'vue';

const loggedIn = ref(false)

const toggle = ref(true)

</script>

<style scoped>

</style>
```

::: warning v-if 与 v-show 的选择比较

| 对比点       | `v-if`                                 | `v-show`                                |
| ------------ | -------------------------------------- | --------------------------------------- |
| 渲染策略     | **按需创建/销毁** DOM 元素             | 创建一次，之后仅切换 `display`          |
| 初始渲染开销 | 较大（每次条件变更都重新渲染）         | 较小（始终存在）                        |
| 适合场景     | 频繁切换不建议，适合条件变化较少的内容 | 适合频繁切换可见性的内容（如 Tab 切换） |
| DOM 保留状态 | 被销毁，状态丢失                       | 状态保留                                |

:::

::: danger 注意
1. 不能同时使用 v-if 和 v-for 在同一元素上
> 可读性差，容易误解优先级。会误认为先判断 v-if 再遍历。实际是先遍历，再判断是否渲染。
``` html
<!-- 不推荐 -->
<li v-for="item in list" v-if="item.visible">{{ item.name }}</li>

<!-- 推荐方式 -->
<li v-for="item in list" v-show="item.visible">{{ item.name }}</li>

<!-- 或者 -->

const visibleItems = computed(() => list.value.filter(item => item.visible))

```

2. v-else 和 v-else-if 必须紧跟 v-if 元素
3. v-show 不影响 v-if 的渲染逻辑
:::

### 列表渲染

- **应用示例(Vu3)**

``` vue
<template>
  <el-card >
    <template #header>v-for 遍历数组</template>
    
    <ul>
      <li v-for="(airline, i) in airlines" :key="i">{{ i }} - {{ airline }}</li>
    </ul>
    <el-button @click="generateAirlines">随机生成飞机</el-button>
  </el-card>
  <br/>
  <el-card >
    <template #header>v-for 遍历对象</template>
    
    <ul>
      <li v-for="(value, key) in person" :key="key">
        <template v-if="getType(value) === 'Object'">
          {{ key }}:
          <ul>
            <li v-for="(value, key) in value" :key="key">{{ key }}: {{ value }}</li>
          </ul>
        </template>
        <template v-else>
          {{ key }}: {{ value }}
        </template>
      </li>
    </ul>
    <el-button @click="generatePerson">随机生成人员信息</el-button>
  </el-card>
  <br/>
  <el-card >
    <template #header>v-for 遍历指定次数 <el-tag>win + 。可以输入表情</el-tag></template>
    
    <el-button @click="generateNumber">随机n个😶‍🌫️</el-button>
    <div>
      <span v-for="n in number" :key="n">😶‍🌫️</span>
    </div>

  </el-card>
  <br/>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { fakerZH_CN as faker } from '@faker-js/faker' 
import { getType } from '@/common'

const airlines = ref([])
const person = ref({})
const number = ref(0)

onMounted(() => {
  generateAirlines()
  generatePerson()
  generateNumber()
});

function generateAirlines(){
  airlines.value.length = 0;
  for (let index = 0; index < 10; index++) {
    airlines.value.push(faker.airline.airline())
  }
}

function generatePerson(){
  person.value = {
    id: faker.string.uuid(),
    fullName: faker.person.fullName(),
    gender: faker.person.sexType(),
    birthday: faker.date.birthdate({ min: 18, max: 65, mode: 'age' }),
    email: faker.internet.email(),
    phone: faker.phone.number(),
    address: {
      country: faker.location.country(),
      city: faker.location.city(),
      street: faker.location.streetAddress(),
      zipCode: faker.location.zipCode(),
    },
    avatar: faker.image.avatar(),
    job: {
      title: faker.person.jobTitle(),
      type: faker.person.jobType(),
      area: faker.person.jobArea(),
    },
  }
}

function generateNumber(){
  number.value = Math.floor(Math.random() * 100) + 1
}

</script>

<style scoped>

</style>
```

::: danger 注意
1. 使用唯一的 ID 作为 key，不要使用数组索引，尤其是列表会增删排序的情况。
2. 不要同时使用 v-if 和 v-for。必要时使用template元素过渡。
:::

### 事件处理

事件处理是响应用户交互（如点击、输入、提交等）最常用的方式之一。Vue 提供了简单直观的语法来绑定 DOM 事件，并执行相应的处理逻辑。

- **事件修饰符列表**
  - `.stop`：单击事件将停止传递
  - `.prevent`：阻止默认行为，如表单提交，链接跳转等
  - `.self`：仅当 event.target 是元素本身时才会触发事件处理器
  - `.capture`：在被内部元素处理前，先被外部(parent)处理
  - `.once`：点击按钮只触发一次
  - `.passive`：被动监听 例如被动监听滚动（不会阻止默认滚动），一般用于触摸事件的监听器，可以用来改善移动端设备的滚屏性能。
  
- **键盘事件列表**
  - `.enter`
  - `.tab`
  - `.delete (捕获“Delete”和“Backspace”两个按键)`
  - `.esc`
  - `.space`
  - `.up`
  - `.down`
  - `.left`
  - `.right`
  - `.ctrl`
  - `.alt`
  - `.shift`
  - `.meta`

- **鼠标事件列表**
  - `.left`
  - `.right`
  - `.middle`

- **自定义事件**
  可以使用"emit"实现自定义事件

- **应用示例(Vu3)**
  
``` vue
<template>
  <el-card >
    <template #header>基本用法</template>
    <!-- 方法处理 -->
    <p>方法事件处理器</p> 
    <el-button @click="sayHello">点击问好</el-button>

    <!-- 内联事件处理器 -->
    <p>内联事件处理器 当前计数：{{ count }}</p> 
    <el-button @click="count++">+</el-button>

    <!-- 内联事件处理器调用方法 -->
    <p>内联事件处理器调用方法</p> 
    <el-button @click="sayMessage('四十二号混凝土')">点击弹框</el-button>

    <!-- 在内联事件处理器中访问事件参数 -->
    <p>在内联事件处理器中访问事件参数</p> 
    <!-- 使用特殊的 $event 变量 -->
    <el-button @click="warn('Form cannot be submitted yet.', $event)">
      提交1
    </el-button>
    <!-- 使用内联箭头函数 -->
    <el-button @click="(event) => warn('Form cannot be submitted yet.', event)">
      提交2
    </el-button>
  </el-card>
  <br/>
  <el-card>
    <template #header>事件修饰符</template>
    <p>stop 单击事件将停止传递</p>
    <!-- stop单击事件将停止传递 -->
    <!-- 不会触发 -->
    <div style="height:150px;background-color: aliceblue; margin: 10px 0;" @click="parentClicked('parent3', $event)">
      <!-- 会触发 -->
      <div style="height:100px;background-color: aquamarine;" @click.stop="parentClicked('parent2', $event)">
        <!-- 会触发 -->
        <div style="height:60px;background-color: aqua;" @click="parentClicked('parent1', $event)">
          <el-button @click="handleSelfClick">点击按钮</el-button>
          <br/>
          parent1
        </div>
        parent2
      </div>
      parent3
    </div>
    <el-divider/>

    <p>self 仅当 event.target 是元素本身时才会触发事件处理器</p>
    <!-- self 仅当 event.target 是元素本身时才会触发事件处理器 -->
    <!-- 例如：事件处理器不来自子元素 -->
    <!-- 不会触发 -->
    <div style="height:100px;background-color: aquamarine; margin: 10px 0;" @click="parentClicked('parentwithself', $event)">
      <!-- 会触发 -->
      <div  style="height:60px;background-color: aqua;" @click.self="parentClicked('parentwithoutself', $event)">
        <el-button @click="handleSelfClick">点击按钮</el-button>
        <br/>
        parentwithoutself
      </div>
      parentwithself
    </div>
    <el-divider/>

    <p>once 点击按钮只触发一次; prevent 点击按钮时阻止默认行为； 可以链式调用</p>
    <el-tag>使用 @click.prevent.self 会阻止元素及其子元素的所有点击事件的默认行为，而 @click.self.prevent 则只会阻止对元素本身的点击事件的默认行为。</el-tag>
    <form @submit.prevent="handleSubmit" style="margin: 10px 0;">
      <el-button @click.stop.once="handleClickOnce">点击我（一次性按钮）</el-button>
    </form>

    <el-divider/>

    <!-- 添加事件监听器时，使用 `capture` 捕获模式 -->
    <!-- 例如：指向内部元素的事件，在被内部元素处理前，先被外部处理 -->
    <p>使用 `capture` 捕获模式，指向内部元素的事件，在被内部元素处理前，先被外部(parent1)处理 </p>
    <div style="height:60px;background-color: aqua;margin: 10px 0;" @click.capture="parentClicked('parent1', $event)">
      <el-button @click="handleSelfClick">捕获按钮</el-button>
      <br/>
      parent1
    </div>
    <el-divider/>

    <!-- 被动监听滚动（不会阻止默认滚动）-->
    <!-- 滚动事件的默认行为 (scrolling) 将立即发生而非等待 `onScroll` 完成 -->
    <!-- 以防其中包含 `event.preventDefault()` -->
    <p>passive 被动监听 例如被动监听滚动（不会阻止默认滚动）</p>
    <p>passive 修饰符一般用于触摸事件的监听器，可以用来改善移动端设备的滚屏性能。</p>
    <div
      style="height:100px;background-color: aqua;margin: 10px 0;overflow: auto;"
      @wheel.passive="handleScroll"
    >
      <div style="height:200px;">
        <ul>
          <li>滚动我</li>
          <li>滚动我</li>
          <li>滚动我</li>
          <li>滚动我</li>
          <li>滚动我</li>
          <li>滚动我</li>
          <li>滚动我</li>
          <li>滚动我</li>
          <li>滚动我</li>
          <li>滚动我</li>
          <li>滚动我</li>
        </ul>
      </div>
  </el-card>
  <br/>
  <el-card>
    <template #header>键盘事件</template>
    <el-input
      autosize
      type="textarea"
      v-model="message"
      @keydown.enter.ctrl="submitMessage"
      @keydown.esc="cancelEdit"
      @keydown.tab.prevent="insertTab"
      placeholder="Ctrl + Enter 提交，Esc 取消，Tab 插入缩进"
    ></el-input>
    <p v-if="submitted">✅ 提交成功：{{ submitted }}</p>
  </el-card>
  <br/>
  <el-card>
    <template #header>鼠标事件</template>
    <!-- 单击事件 -->
    <p>单击事件</p>
    <el-button  @click="handleClick" style="margin:10px 0">单击我</el-button >
    <el-divider></el-divider>
    <!-- 双击事件 -->
    <p>双击事件</p>
    <el-button @dblclick="handleDoubleClick" style="margin:10px 0">双击我</el-button>
    <el-divider></el-divider>
    <!-- 按下和松开 -->
    <div
      class="box"
      @mousedown="handleMouseDown"
      @mouseup="handleMouseUp"
      style="height: 100px; margin:10px 0;background-color: cadetblue;"
    >
      {{ mouseDownUp }}
    </div>
    <el-divider></el-divider>
    <!-- 鼠标进入和离开 -->
    <div
      class="box"
      @mouseenter="handleMouseEnter"
      @mouseleave="handleMouseLeave"
      style="height: 100px; margin:10px 0;background-color: cadetblue;"
    >
      {{mouseEnterLeave}}
    </div>
    <el-divider></el-divider>
    <!-- 鼠标移动 -->
    <div
      class="box"
      @mousemove="handleMouseMove"
      style="height: 100px; margin:10px 0;background-color: cadetblue;"
    >
      鼠标移动区域，移动位置：X: {{ mouseX }}, Y: {{ mouseY }}
    </div>
  </el-card>
</template>

<script setup>
import { ref, onMounted } from 'vue';

const count = ref(0)

onMounted(() => {

});

function sayHello(){
  alert("你家人好嘛？")
}

function sayMessage(message){
  alert(message)
}

function warn(message, event) {
  // 这里可以访问原生事件
  if (event) {
    // 阻止默认行为，如表单提交链接跳转
    event.preventDefault()
    alert(`${event.srcElement.innerText} : ${message}`)
  }
  
}

function handleSubmit() {
  alert("表单提交被阻止！");
}

function handleClickOnce() {
  alert("你只会看到这一次！");
}

function handleSelfClick() {
  alert("你点击按钮！");
}

function parentClicked(from, event) {
  if(event.target !== event.currentTarget){
    alert(`父元素${from} 被点击（冒泡）`);
  }
  alert(`父元素${from} 被点击（本身）`);
}

function handleScroll() {
  alert("滚动事件触发");
}

const message = ref('')
const submitted = ref('')

function submitMessage() {
  if (message.value.trim()) {
    submitted.value = message.value
    message.value = ''
  } else {
    alert('内容不能为空')
  }
}

function cancelEdit() {
  message.value = ''
  alert('编辑已取消')
}

function insertTab(event) {
  const textarea = event.target
  const start = textarea.selectionStart
  const end = textarea.selectionEnd
  const value = textarea.value

  // 插入4个空格
  textarea.value = value.substring(0, start) + '    ' + value.substring(end)
  textarea.selectionStart = textarea.selectionEnd = start + 4

  // 手动触发 v-model 更新
  message.value = textarea.value
}

const mouseX = ref(0);
const mouseY = ref(0);

const mouseDownUp = ref("按下或松开鼠标")
const mouseEnterLeave = ref("鼠标进入和离开区域")

function handleClick(event) {
  alert('单击事件触发');
}

function handleDoubleClick(event) {
  alert('双击事件触发');
}

function handleMouseDown(event) {
  mouseDownUp.value = `鼠标按下`
}

function handleMouseUp(event) {
  mouseDownUp.value = `鼠标松开`
}

function handleMouseEnter(event) {
  mouseEnterLeave.value = `鼠标进入`
}

function handleMouseLeave(event) {
  mouseEnterLeave.value = `鼠标离开`
}

function handleMouseMove(event) {
  mouseX.value = event.offsetX;
  mouseY.value = event.offsetY;
}
</script>

<style scoped>

</style>
```

### 表单输入绑定

表单绑定主要通过 v-model 指令来实现，它可以双向绑定输入控件与组件的数据。

- **应用示例(Vu3)**

``` vue
<template>
  <el-card>
    <template #header>表单绑定</template>
    <el-form :model="form" label-width="auto" style="max-width: 600px" :rules="rules" ref="formRef">
      <el-form-item label="Activity name" prop="name">
        <el-input v-model.trim="form.name" />
      </el-form-item>
      <el-form-item label="Activity zone" prop="region">
        <el-select v-model="form.region" placeholder="please select your zone">
          <el-option label="Zone one" value="shanghai" />
          <el-option label="Zone two" value="beijing" />
        </el-select>
      </el-form-item>
      <el-form-item label="Number of participants" prop="participants">
        <el-input type="number" min="0" v-model.number="form.participants" />
      </el-form-item>
      <el-form-item label="Activity time">
        <el-col :span="11">
          <el-date-picker
            v-model="form.date1"
            type="date"
            placeholder="Pick a date"
            style="width: 100%"
          />
        </el-col>
        <el-col :span="2" class="text-center">
          <span class="text-gray-500">-</span>
        </el-col>
        <el-col :span="11">
          <el-time-picker
            v-model="form.date2"
            placeholder="Pick a time"
            style="width: 100%"
          />
        </el-col>
      </el-form-item>
      <el-form-item label="Instant delivery">
        <el-switch v-model="form.delivery" />
      </el-form-item>
      <el-form-item label="Activity type">
        <el-checkbox-group v-model="form.type">
          <el-checkbox value="Online activities" name="type">
            Online activities
          </el-checkbox>
          <el-checkbox value="Promotion activities" name="type">
            Promotion activities
          </el-checkbox>
          <el-checkbox value="Offline activities" name="type">
            Offline activities
          </el-checkbox>
          <el-checkbox value="Simple brand exposure" name="type">
            Simple brand exposure
          </el-checkbox>
        </el-checkbox-group>
      </el-form-item>
      <el-form-item label="Resources">
        <el-radio-group v-model="form.resource">
          <el-radio value="Sponsor">Sponsor</el-radio>
          <el-radio value="Venue">Venue</el-radio>
        </el-radio-group>
      </el-form-item>
      <el-form-item label="Activity form">
        <el-input v-model="form.desc" type="textarea" />
      </el-form-item>
      <el-form-item label = "Acceptthe user agreement">
        <el-checkbox v-model="form.accepted" true-value="yes" false-value="no"/>
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click="onSubmit">Submit</el-button>
        <el-button @click="onReset">Reset</el-button>
      </el-form-item>
    </el-form>

    <el-divider></el-divider>

    <p>提交结果</p>
    <p v-if="submitted">{{ form }}</p>
    <p v-else>表单正在输入</p>

  </el-card>
  
</template>

<script lang="ts" setup>
import { ref, reactive, watch } from 'vue'
import { FormInstance, FormRules, ElMessage} from 'element-plus'

//用于检验
const formRef = ref<FormInstance> ()
const form = reactive({
  name: '',
  region: '',
  participants: 0,
  date1: '',
  date2: '',
  delivery: false,
  type: [],
  resource: '',
  desc: '',
  accepted: 'yes'
})

const checkParticipants = (rule: any, value: any, callback: any) => {
  if (!Number.isInteger(value)) {
    callback(new Error('Please input digits'))
  } else{
    if (value > 18) {
      callback(new Error('Participants must be less than 18'))
    } else {
      callback()
    }
  }
}

const rules = reactive<FormRules>({
  name: [
    { required: true, message: 'Please input Activity name', trigger: 'blur' },
    { min: 3, max: 5, message: 'Length should be 3 to 5', trigger: 'blur' },
  ],
  region: [
    { required: true,  message: 'Please select Activity zone', trigger: 'change', }
  ],
  participants: [
    { required: true, validator: checkParticipants,  trigger: 'blur' }
  ],
})


const submitted = ref(false)

const onSubmit = async () => {
  if(!formRef.value) return;
  await formRef.value.validate((valid, fields) => {
    if (valid) { 
      ElMessage({
        message: '提交成功.',
        type: 'success',
      })

      submitted.value = true;
      return
    } 
    ElMessage.error('验证失败！')
  })
}

const onReset = () => {
  submitted.value = false
  form.name= '',
  form.region= '',
  form.date1= '',
  form.date2= '',
  form.delivery= false,
  form.type= [],
  form.resource=  '',
  form.desc= '',
  form.accepted= 'yes'
}

watch(form, async (newValue, oldValue) => {
  submitted.value = false;
},{ deep: true })

</script>
```

- **修饰符**
- `.lazy​`
默认情况下，v-model 会在每次 input 事件后更新数据 (IME 拼字阶段的状态例外)。你可以添加 lazy 修饰符来改为在每次 change 事件后更新数据：

``` vue
<!-- 在 "change" 事件后同步更新而不是 "input" -->
<input v-model.lazy="msg" />
```

- `.number​`
如果你想让用户输入自动转换为数字，你可以在 v-model 后添加 .number 修饰符来管理输入：

``` vue
<input v-model.number="age" />
```
如果该值无法被 parseFloat() 处理，那么将返回原始值。特别是当输入为空时 (例如用户清空输入字段之后)，会返回一个空字符串。这种行为与 DOM 属性 valueAsNumber 有所不同。

number 修饰符会在输入框有 type="number" 时自动启用。

- `.trim​`
如果你想要默认自动去除用户输入内容中两端的空格，你可以在 v-model 后添加 .trim 修饰符：

``` vue
<input v-model.trim="msg" />
```

### 侦听器

### 模板引用

## 组件

## 逻辑复用

## 应用规模化

## vuex

## vue-router

## Element-UI

## http请求